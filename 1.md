

#### 1. 变量声明基础
**题目：var、let 和 const 的区别是什么？**  
**答案：**  
- `var`：函数作用域（function-scoped），允许重新声明和赋值，支持提升（hoisted），初始化为 undefined。  
- `let`：块级作用域（block-scoped），允许重新赋值但不允许重新声明，支持提升但有 Temporal Dead Zone (TDZ)。  
- `const`：块级作用域，不允许重新赋值（但对象属性可修改），不允许重新声明，支持提升但有 TDZ，必须初始化。  
**示例：**  
```javascript
var a = 1; var a = 2; // 允许
let b = 3; // let b = 4; // 错误：重新声明
const c = 5; // c = 6; // 错误：重新赋值
const obj = { name: 'Alice' }; obj.name = 'Bob'; // 允许修改属性
```

**题目：JavaScript 中变量命名有哪些限制？**  
**答案：**  
变量名必须以字母、下划线或美元符号开头，可包含字母、数字、下划线或美元符号，不能是保留字，不能包含空格。JavaScript 是区分大小写的。  
**示例：**  
```javascript
let firstName = 'Alice'; // 驼峰式（camelCase），推荐用于变量
let FirstName = 'Bob'; // PascalCase，推荐用于构造函数
// let 1name = 'error'; // 错误：不能以数字开头
```

**题目：什么是变量阴影（shadowing）？**  
**答案：**  
内层作用域中声明的同名变量会“遮蔽”外层作用域的变量，在内层作用域内优先使用内层变量。  
**示例：**  
```javascript
let x = 'outer';
function test() {
  let x = 'inner';
  console.log(x); // 'inner'
}
test();
console.log(x); // 'outer'
```

#### 2. 作用域相关
**题目：JavaScript 中的作用域类型有哪些？**  
**答案：**  
- 全局作用域（global scope）：在函数外部声明，可全局访问。  
- 函数作用域（function scope）：在函数内部声明，仅函数内访问（var）。  
- 块级作用域（block scope）：在 {} 块内声明，仅块内访问（let/const）。  
**示例：**  
```javascript
let globalVar = 'global'; // 全局
function func() {
  var funcVar = 'function scope'; // 函数作用域
  if (true) {
    let blockVar = 'block scope'; // 块级
    console.log(blockVar); // 可访问
  }
  // console.log(blockVar); // 错误
}
```

**题目：什么是作用域链（scope chain）？**  
**答案：**  
作用域链是 JavaScript 查找变量的机制，从当前作用域开始向上层作用域搜索，直到全局作用域。  
**示例：**  
```javascript
let outerVar = 'outer';
function outer() {
  function inner() {
    console.log(outerVar); // 通过作用域链访问 'outer'
  }
  inner();
}
outer();
```

**题目：全局变量和局部变量的区别是什么？**  
**答案：**  
全局变量在函数外部声明，可全局访问，容易造成污染。局部变量在函数或块内声明，仅限该作用域访问。  
**示例：**  
```javascript
let global = 'global';
function test() {
  let local = 'local';
  console.log(global); // 可访问
}
test();
// console.log(local); // 错误
```

#### 3. 提升与 TDZ
**题目：什么是提升（hoisting）？**  
**答案：**  
提升是 JavaScript 在执行前将变量和函数声明移到作用域顶部的行为。var 被提升并初始化为 undefined；let/const 被提升但不初始化，导致 TDZ。  
**示例：**  
```javascript
console.log(a); // undefined
var a = 1;

console.log(b); // ReferenceError (TDZ)
let b = 2;
```

**题目：什么是 Temporal Dead Zone (TDZ)？**  
**答案：**  
TDZ 是从块开始到 let/const 声明前的“死区”，在此期间访问变量会抛出 ReferenceError。  
**示例：**  
```javascript
console.log(x); // ReferenceError
let x = 10;
```

**题目：let 和 const 是否被提升？**  
**答案：**  
是的，但它们在 TDZ 中不可访问，直到声明语句执行。  
**示例：**  
```javascript
console.log(y); // ReferenceError
const y = 20;
```

#### 4. 实际应用与陷阱
**题目：为什么在循环中使用 var 会出问题，而 let 不会？**  
**答案：**  
var 是函数作用域，所有迭代共享同一个变量；let 是块级作用域，每轮迭代创建一个新变量。  
**示例：**  
```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100); // 3, 3, 3
}

for (let j = 0; j < 3; j++) {
  setTimeout(() => console.log(j), 100); // 0, 1, 2
}
```

**题目：const 声明的对象或数组可以修改吗？**  
**答案：**  
不能重新赋值整个对象，但可以修改其属性或元素，因为 const 保护的是引用。  
**示例：**  
```javascript
const arr = [1, 2];
arr.push(3); // [1, 2, 3] 允许
// arr = [4]; // 错误
```

**题目：不使用 var/let/const 直接赋值会怎样？**  
**答案：**  
在非严格模式下，会创建全局变量（污染全局作用域）；在严格模式下，会抛出错误。推荐始终使用声明关键字。  
**示例：**  
```javascript
function test() {
  z = 10; // 全局变量
}
test();
console.log(z); // 10
```

**题目：var 为什么不推荐在现代 JS 中使用？**  
**答案：**  
var 是函数作用域且支持提升，容易导致 bug（如意外全局变量）。let/const 提供块级作用域，更安全和可预测。

**题目：null 和 undefined 的区别是什么？**  
**答案：**  
undefined 表示变量声明但未赋值；null 表示有意设置为空值。两者在松散比较中相等（==），但严格不相等（===）。  
**示例：**  
```javascript
let undef;
console.log(undef); // undefined
let nul = null;
console.log(nul); // null
console.log(null == undefined); // true
```
