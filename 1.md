`Array.isArray()` 是 JavaScript 中**唯一 100% 准确判断“某个值是不是真数组”**的方法。  
它在 ES5（2009 年）就引入了，到 2025 年已经所有浏览器（包括 IE9+）都完美支持。

### 一、基本用法（简单到爆）
```js
Array.isArray(value)
```
- 返回 `true` → 一定是数组
- 返回 `false` → 一定不是数组

```js
Array.isArray([])                    // true
Array.isArray([1, 2, 3])             // true
Array.isArray(new Array(5))          // true

Array.isArray({})                    // false
Array.isArray("abc")                 // false
Array.isArray(undefined)             // false
Array.isArray(null)                  // false
Array.isArray(123)                   // false
Array.isArray(true)                  // false
Array.isArray(() => {})              // false
Array.isArray({ __proto__: Array.prototype }) // false！类数组
```

### 二、为什么必须用 Array.isArray？（其他方法全都有坑）

| 判断方法                     | 问题（会被坑死的例子）                                 | 结果 |
|------------------------------|--------------------------------------------------------|------|
| `value instanceof Array`     | 跨 iframe 创建的数组                                   | false |
| `Object.prototype.toString.call(value) === '[object Array]'` | 虽然最稳，但写起来太长                     | true |
| `Array.prototype.isPrototypeOf(value)` | 同 instanceof，跨 window 失效             | false |
| `value.constructor === Array` | 可以被改写或删除                                       | 不安全 |
| `typeof value === 'object'`   | 对象、null、数组都返回 object                          | 错得离谱 |

真实案例（跨 iframe 场景，面试必考）：
```js
const iframe = document.createElement('iframe');
document.body.appendChild(iframe);
const foreignArray = iframe.contentWindow.Array;

// 这两个 Array 是完全不同的构造函数！
foreignArray.isArray([])          // true（原生支持）
foreignArray instanceof Array     // false！！
Array.is627Array(foreignArray)    // true（因为原生方法能识别）
```

**结论：只有 `Array.isArray()` 能跨 iframe 正确判断！**

### 三、实际项目中 99% 都是这么用的（标准写法大全）

```js
// 1. 最常见：函数参数防御性编程
function sum(arr) {
  if (!Array.isArray(arr)) {
    throw new TypeError('Expected an array');
  }
  return arr.reduce((a, b) => a + b, 0);
}

// 2. 条件判断
if (Array.isArray(data)) {
  // 安全处理
  data.map(...)
}

// 3. Vue/React 中判断 props
props: {
  list: {
    type: Array,
    required: true,
    validator: value => Array.isArray(value)
  }
}

// 4. 工具库封装（lodash 也是这么干的）
export const isArray = Array.isArray;

// 5. 兼容极老浏览器（IE8 及以下）写法
const isArray = Array.isArray || function(val) {
  return Object.prototype.toString.call(val) === '[object Array]';
};
```

### 四、一张图记住所有判断数组的方法对比（2025 版）

| 方法                              | 是否推荐 | 跨 iframe | 原始类型安全 | 性能 | 备注 |
|-----------------------------------|----------|-----------|--------------|------|------|
| `Array.isArray(val)`              | ★★★★★    | 支持      | 安全         | 最快 | 官方唯一推荐 |
| `val instanceof Array`            | ★★       | 不支持    | 安全         | 快   | 跨 window 失效 |
| `Object.prototype.toString.call(val) === '[object Array]'` | ★★★★ | 支持      | 安全         | 稍慢 | 最万能 |
| `val.constructor === Array`       | ★        | 支持      | 不安全       | 快   | 容易被改 |
| `Array.prototype.isPrototypeOf(val)` | ★★   | 不支持    | 安全         | 快   | 同 instanceof |

### 五、终极结论（背下来就无敌了）

| 场景                     | 永远写这个                               |
|--------------------------|------------------------------------------|
| 任何时候判断是不是数组   | `Array.isArray(value)`                   |
| 写工具库、框架、组件     | `Array.isArray(value)`                   |
| 面试被问怎么判断数组     | “用 Array.isArray，它是唯一跨 iframe 正确的方法” |

一句话记住：
> **2025 年了，判断数组就只用一句话：`Array.isArray()`，其他全是坑！**

从今天起，把你项目里所有的 `instanceof Array`、`typeof arr === 'object'` 统统删掉，换成 `Array.isArray()`，代码立刻升级 10 年！