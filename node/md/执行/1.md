下面我给你一套 **NestJS 的“完整执行链大全”**（最权威、最完整、最清晰），涵盖：

* 所有生命周期顺序（HTTP、Pipe、Guard、Middleware、Interceptor、Filter）
* 各阶段触发条件
* 全局 vs 局部 vs 控制器级别的执行顺序
* 何时跳链、短路、异常如何流动
* 完整时序图（ASCII）
* 特别注意点（NestJS 官方没讲清楚的地方）

> **这是一个“企业级” NestJS 运行机制总览，你学会后相当于掌握 NestJS 内核。**

---

# 🚀 第一章：NestJS HTTP 请求完整执行链（总览）

**一次 HTTP 请求从进来到最终响应的执行顺序是：**

```
HTTP Server(Express/Fastify)
     ↓
Middleware（中间件）
     ↓
Guards（守卫）
     ↓
Interceptors（前置部分）
     ↓
Pipes（参数转换与校验）
     ↓
Controller（路由方法）
     ↓
Service（业务逻辑）
     ↓
Interceptors（后置部分）
     ↓
Exception Filters（异常过滤器）
     ↓
HTTP Response
```

这是 **99% 的 NestJS 项目核心链路**。

---

# 🧩 第二章：每一环节详解 + 执行规则 + 触发条件

下面把所有环节按顺序讲透。

---

# ⭐ 1. HTTP Server（Express/Fastify）

Nest 不是自己监听端口，而是构建在 Express 或 Fastify 之上。

功能：

* 接收请求
* 调用 Nest 的内部路由系统

---

# ⭐ 2. Middleware（中间件）

特点：

* 按注册顺序执行
* **在 Guard 之前运行**
* 修改 req/res
* 常用于：

  * 日志
  * 加 traceId
  * token 放到 req 上（但不能做鉴权）

触发条件：

* 所有请求都会触发它（如果你 forRoutes('*')）

局部示例：

```ts
consumer.apply(LoggerMiddleware).forRoutes('*');
```

---

# ⭐ 3. Guards（守卫）

特点：

* 控制“是否允许进入 Controller”
* **可以阻断执行链**
* 常用于：

  * 身份认证（JWT）
  * 权限控制（RBAC）
  * 白名单检查

Guard 返回：

* **true** → 链继续
* **false / 异常** → 直接交给 ExceptionFilter

触发条件：

* Controller 或方法上使用 `@UseGuards()`
* 或通过全局 `app.useGlobalGuards()`

---

# ⭐ 4. Interceptors（前置）

这是 Nest 的“切面编程（AOP）”能力。

前置阶段功能：

* 在 Controller 方法执行前做事，如：

  * 请求耗时记录
  * 数据缓存（before 部分检查 cache）
  * 日志

触发条件：

* 方法级
* 类级（Controller）
* 全局级
* **按“外层先入，内层后入”顺序进入**

即：

```
全局 → Controller → 方法
```

---

# ⭐ 5. Pipes（管道）

特点：

* 处理参数（param / query / body）
* DTO 校验（ValidationPipe）
* 类型转换（ParseIntPipe）

执行规则：

* **只在参数解析阶段执行**
* 执行顺序：

  1. 全局 Pipe
  2. Controller 层 Pipe
  3. 方法参数指定的 Pipe（最靠近参数，优先级最高）

如果 DTO 校验失败 → 抛异常 → 进入 Filter

---

# ⭐ 6. Controller

特点：

* 仅负责路由，逻辑必须轻
* 参数已经经过 Pipe 转换
* 当前已通过 Guard 验证
* 进入 Controller 时：

  * Interceptor before 已执行
  * Middleware 已执行
  * Pipe 已执行
  * Guard 已验证

---

# ⭐ 7. Service（业务逻辑）

* 由 DI 自动注入
* 一般不做请求相关的事（除非写 @Injectable() 的 helper）

---

# ⭐ 8. Interceptors（后置）

在 Controller + Service 执行完成后，Interceptor 的后置阶段执行。

执行特点：

* **按栈顺序推出（后进先出）**
* 可以：

  * 修改最终响应（包装 data）
  * 捕获内部异常（catchError）
  * 日志
  * 缓存结果
  * 流式数据处理（map）

---

# ⭐ 9. Exception Filters（异常过滤器）

捕获全程中的异常。

触发条件：

* 任何位置抛出异常（Guard / Pipe / Service / Controller / Interceptor）
* Filter 会接管异常，并返回统一格式

Filter 的优先级：

1. 方法级 `@UseFilters()`
2. Controller 级
3. 全局 `app.useGlobalFilters`

注意：

* Interceptor 的 catchError 可以**在 Filter 之前**截获异常
* 这是 Interceptor 的强大能力

---

# ⭐ 10. HTTP 响应

最终返回给客户端。

---

# 🎯 第三章：完整执行链时序图（终极图）

下面是最完整的 NestJS 链路，**被很多人收藏的标准图**：

```
┌─────────────────────────────────────────┐
│          HTTP Request Arrives          │
└─────────────────────────────────────────┘
                  │
                  ▼
        ┌───────────────────────┐
        │     Middleware        │
        └───────────────────────┘
                  │
                  ▼
        ┌───────────────────────┐
        │        Guards         │
        └───────────────────────┘
                  │ (if false → ExceptionFilter)
                  ▼
        ┌───────────────────────┐
        │  Interceptors Before  │────────┐
        └───────────────────────┘        │
                  │                      │
                  ▼                      │
          ┌─────────────────┐            │
          │      Pipes      │            │
          └─────────────────┘            │
                  │ (参数校验/转换)       │
                  ▼                      │
        ┌───────────────────────┐        │
        │      Controller        │        │
        └───────────────────────┘        │
                  │                      │
                  ▼                      │
        ┌───────────────────────┐        │
        │        Service         │        │
        └───────────────────────┘        │
                  │                      │
                  ▼                      │
        ┌───────────────────────┐        │（倒序执行）
        │  Interceptors After   │◄───────┘
        └───────────────────────┘
                  │
                  ▼
       ┌──────────────────────────┐
       │     Exception Filter     │(仅异常时触发)
       └──────────────────────────┘
                  │
                  ▼
        ┌───────────────────────┐
        │    HTTP Response      │
        └───────────────────────┘
```

---

# 🧠 第四章：关键注意点（官方没讲清楚的）

---

## 1）**Guard 是整个链路中最早可以“拒绝请求”的环节**

拒绝后：

* 后面的 Interceptor / Pipes / Controller 都不会执行
* 直接抛异常 → ExceptionFilter

---

## 2）**Pipes 只针对参数，不会对整个请求触发**

例如：

```ts
@Get(':id')
getUser(@Param('id', ParseIntPipe) id: number)
```

只在取 `id` 时执行，不会全局执行。

---

## 3）**Interceptor 是唯一可以同时包裹 Controller 前后逻辑的层**

因此它能实现：

* AOP
* 缓存
* 日志
* 响应格式包装
* 异常拦截
* 性能监控

是企业项目核心。

---

## 4）**Exception Filter 是最后的兜底层**

如果你全局挂了：

```ts
app.useGlobalFilters(new HttpExceptionFilter());
```

那么所有抛出的异常最后都会到这里。

除非被 Interceptor catch 掉。

---

## 5）全局 → Controller → 方法级别的优先级

各种“UseXXX”的优先级：

```
Global > Controller > Method
```

执行顺序（before）：

```
Global → Controller → Method
```

（after 部分逆序）

---

# 🏆 最终总结：NestJS 执行链口诀

你可以记这条：

> **中间件先，守卫拦，拦截器前再管一管，
> 管道转，控制器干正活，服务层跑逻辑，
> 出来拦截器再加工，异常过滤来兜底。**

只要记住这句话，Nest 的核心就掌握了。

---

如果你愿意，我可以：

✔ 用你写的项目画一个“真实请求的时序图”
✔ 给你写一个能打印每一环节“进入/退出日志”的 DEMO
✔ 演示**异常链路全过程**
✔ 或继续讲 “Module 解析机制”“依赖注入执行链 DI container 全流程”

你想继续哪个？
