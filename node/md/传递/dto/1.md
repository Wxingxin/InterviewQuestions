好嘞，下面给你一份 **NestJS / class-validator 装饰器速查表（常用+高频+进阶）**，并且**每一类都给经典代码范式**。你可以当成项目里的“校验字典”。

---

# 0. 经典全局管道（生产标配）

```ts
// main.ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,
    forbidNonWhitelisted: true,
    transform: true,
    transformOptions: { enableImplicitConversion: true },
    stopAtFirstError: false,
  }),
);
```

---

# 1. 类型类校验

## 字符串

* `@IsString()` 必须是 string
* `@IsNotEmpty()` 不能为空字符串
* `@MinLength(n)` 最小长度
* `@MaxLength(n)` 最大长度
* `@Length(min, max)` 长度范围
* `@Matches(regexp)` 正则
* `@IsIn([...])` 必须在枚举里
* `@IsLowercase()` / `@IsUppercase()`

**经典代码：登录/注册 DTO**

```ts
export class RegisterDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8)
  @MaxLength(32)
  @Matches(/^(?=.*[A-Z])(?=.*\d).+$/, {
    message: '密码至少包含一个大写字母和一个数字',
  })
  password: string;

  @IsString()
  @IsNotEmpty()
  nickname: string;
}
```

---

## 数字/整数

* `@IsNumber()` 数字（可小数）
* `@IsInt()` 整数
* `@Min(x)` 最小值
* `@Max(x)` 最大值
* `@IsPositive()` 正数
* `@IsNegative()` 负数

**经典代码：分页 DTO**

```ts
export class PageDto {
  @IsInt()
  @Min(1)
  page: number;

  @IsInt()
  @Min(1)
  @Max(100)
  size: number;
}
```

---

## 布尔

* `@IsBoolean()`

```ts
export class ToggleDto {
  @IsBoolean()
  enabled: boolean;
}
```

---

## 数组

* `@IsArray()` 必须数组
* `@ArrayMinSize(n)` 最小长度
* `@ArrayMaxSize(n)` 最大长度
* `@ArrayNotEmpty()` 不允许空数组
* `@IsString({each:true})` 校验每个元素类型

**经典代码：标签 DTO**

```ts
export class TagsDto {
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  tags: string[];
}
```

---

## 对象

* `@IsObject()` 必须 object
* `@IsNotEmptyObject()` 不能为空对象

```ts
export class MetaDto {
  @IsObject()
  meta: Record<string, any>;
}
```

---

## 日期/时间

* `@IsDate()` 必须 Date 对象（配合 transform）
* `@IsDateString()` ISO 字符串日期
* `@MinDate(date)` / `@MaxDate(date)`

**经典代码：预约 DTO**

```ts
export class BookingDto {
  @IsDateString()
  startAt: string;

  @IsDateString()
  endAt: string;
}
```

---

## Email/URL/UUID/手机号

* `@IsEmail()`
* `@IsUrl()`
* `@IsUUID()`
* `@IsPhoneNumber("CN")`

```ts
export class ContactDto {
  @IsPhoneNumber("CN")
  phone: string;

  @IsUrl()
  homepage: string;

  @IsUUID()
  userId: string;
}
```

---

# 2. 可选/默认/空值逻辑

* `@IsOptional()` 不传就跳过校验
* `@ValidateIf(fn)` 条件生效
* `@IsDefined()` 必须出现（比 `@IsNotEmpty` 更硬）

**经典代码：支付方式条件校验**

```ts
export class PayDto {
  @IsIn(['card', 'cash'])
  method: 'card' | 'cash';

  @ValidateIf(o => o.method === 'card')
  @IsString()
  cardNo?: string;

  @ValidateIf(o => o.method === 'cash')
  @IsInt()
  @Min(0)
  cashAmount?: number;
}
```

---

# 3. 嵌套对象/数组对象校验（非常常用）

核心组合：

* `@ValidateNested()`
* `@Type(() => SubDto)`

**经典代码：订单 DTO**

```ts
class OrderItemDto {
  @IsString()
  sku: string;

  @IsInt()
  @Min(1)
  qty: number;
}

export class CreateOrderDto {
  @IsString()
  userId: string;

  @IsArray()
  @ValidateNested({ each: true })
  @Type(() => OrderItemDto)
  items: OrderItemDto[];
}
```

> **不写 `@Type`，嵌套校验会失效**（超级常见坑）。

---

# 4. 业务级复合校验

## 4.1 字段相等（确认密码）

用 `@Validate` 自定义装饰器：

```ts
import {
  registerDecorator, ValidationArguments, ValidationOptions
} from "class-validator";

export function IsSameAs(
  property: string,
  options?: ValidationOptions,
) {
  return (obj: any, propName: string) => {
    registerDecorator({
      name: "isSameAs",
      target: obj.constructor,
      propertyName: propName,
      options,
      constraints: [property],
      validator: {
        validate(value: any, args: ValidationArguments) {
          const [relatedProp] = args.constraints;
          return value === (args.object as any)[relatedProp];
        },
        defaultMessage(args) {
          const [relatedProp] = args.constraints;
          return `${args.property} must equal ${relatedProp}`;
        },
      },
    });
  };
}
```

使用：

```ts
export class ResetPwdDto {
  @IsString()
  password: string;

  @IsString()
  @IsSameAs('password', { message: '两次密码不一致' })
  confirmPassword: string;
}
```

---

## 4.2 唯一性/存在性校验（连数据库）

思路：自定义 validator + 注入 service
（这里给范式，你能直接套）

```ts
import { ValidatorConstraint, ValidatorConstraintInterface } from "class-validator";
import { Injectable } from "@nestjs/common";
import { UsersService } from "../users.service";

@ValidatorConstraint({ async: true })
@Injectable()
export class IsEmailUniqueConstraint implements ValidatorConstraintInterface {
  constructor(private users: UsersService) {}

  async validate(email: string) {
    const user = await this.users.findByEmail(email);
    return !user;
  }

  defaultMessage() {
    return "email 已存在";
  }
}
```

DTO 里：

```ts
import { Validate } from "class-validator";
import { IsEmailUniqueConstraint } from "./validators/is-email-unique";

export class RegisterDto {
  @IsEmail()
  @Validate(IsEmailUniqueConstraint)
  email: string;
}
```

---

# 5. DTO 复用：PartialType / PickType / OmitType

**最经典 Update DTO：**

```ts
export class UpdateUserDto extends PartialType(CreateUserDto) {}
```

**只取部分字段：**

```ts
export class LoginDto extends PickType(RegisterDto, ['email', 'password'] as const) {}
```

**排除部分字段：**

```ts
export class PublicUserDto extends OmitType(UserEntity, ['password'] as const) {}
```

---

# 6. 错误格式统一（企业常用）

让返回错误更干净：

```ts
app.useGlobalPipes(
  new ValidationPipe({
    exceptionFactory(errors) {
      const formatted = errors.map(e => ({
        field: e.property,
        errors: Object.values(e.constraints ?? {}),
      }));
      return new BadRequestException(formatted);
    },
  }),
);
```

返回：

```json
[
  { "field": "email", "errors": ["email must be an email"] },
  { "field": "age", "errors": ["age must not be less than 0"] }
]
```

---

# 7. 一张“高频装饰器速查表”

### 字符串

* `IsString`
* `IsNotEmpty`
* `MinLength`
* `MaxLength`
* `Length`
* `Matches`
* `IsIn`
* `IsEmail`
* `IsUrl`
* `IsUUID`

### 数字

* `IsInt`
* `IsNumber`
* `Min`
* `Max`
* `IsPositive`
* `IsNegative`

### 数组

* `IsArray`
* `ArrayNotEmpty`
* `ArrayMinSize`
* `ArrayMaxSize`
* `{ each: true }`

### 可选/条件

* `IsOptional`
* `ValidateIf`
* `IsDefined`

### 嵌套

* `ValidateNested`
* `Type(() => XxxDto)`

### 日期

* `IsDate`
* `IsDateString`
* `MinDate`
* `MaxDate`

