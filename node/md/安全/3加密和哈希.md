我直接给你按“实战工程师脑图”的方式来整理：**NestJS 里“加密 + 哈希”能做什么、用什么库、典型代码怎么写、踩坑点在哪**。你可以直接把下面的代码当模板用。

---

## 一、先分清几个概念（非常重要）

1. **哈希（Hash）**

   * 单向不可逆：典型如 `bcrypt`、`argon2`、`scrypt`
   * 常用于：**密码存储**、签名前的摘要等
   * 特点：同样输入 ≈ 同样输出（同盐 & 同参数）

2. **加密（Encryption）**

   * 可逆：有密钥才能解密
   * 对称加密：`AES-256-GCM` 等（一个 secret）
   * 非对称加密：RSA/ECC（公钥加密，私钥解密，或相反）

3. **签名（Signature / MAC）**

   * 验证“完整性 + 发送者”
   * HMAC（对称，常用 sha256）
   * 非对称签名（RSA/ECDSA）

在 NestJS 里，一般场景是：

* 用户密码：**哈希，不可逆（bcrypt/argon2）**
* 需要可解密的敏感信息（如银行卡号）：**对称加密（AES）**
* 接口防篡改 / 与第三方通信：**HMAC / 签名**

---

## 二、密码哈希：bcrypt 经典用法（最常用）

### 1. 安装

```bash
npm i bcrypt
npm i -D @types/bcrypt
```

### 2. 封装一个 HashService（推荐做法）

```ts
// crypto/hash.service.ts
import { Injectable } from '@nestjs/common';
import * as bcrypt from 'bcrypt';

@Injectable()
export class HashService {
  private readonly saltRounds = 10; // 实战可调大一点，注意性能

  async hash(plain: string): Promise<string> {
    const salt = await bcrypt.genSalt(this.saltRounds);
    return bcrypt.hash(plain, salt);
  }

  async compare(plain: string, hash: string): Promise<boolean> {
    return bcrypt.compare(plain, hash);
  }
}
```

### 3. 用户密码注册 / 登录示例

```ts
// users/users.service.ts
import { Injectable, BadRequestException } from '@nestjs/common';
import { HashService } from '../crypto/hash.service';

@Injectable()
export class UsersService {
  constructor(private readonly hashService: HashService) {}

  // 注册时保存密码
  async register(username: string, password: string) {
    const passwordHash = await this.hashService.hash(password);
    // TODO: 存入数据库
    // insert into users (username, password_hash) values ...
    return { username, passwordHash };
  }

  // 登录时验证密码
  async validateUser(username: string, password: string) {
    const user = await this.findByUsername(username);
    if (!user) throw new BadRequestException('用户不存在');

    const isMatch = await this.hashService.compare(
      password,
      user.passwordHash,
    );
    if (!isMatch) throw new BadRequestException('密码不正确');

    // 返回脱敏后的 user
    const { passwordHash, ...safeUser } = user;
    return safeUser;
  }

  // 伪代码
  private async findByUsername(username: string) {
    // 从数据库查 user
    return null;
  }
}
```

### 4. bcrypt 的实战要点

* **永远不要存明文密码**
* `saltRounds` 越大越安全但越慢（常见 10~12，视服务器性能而定）
* 同一个密码 + 不同 salt → 不同 hash（防止彩虹表）

---

## 三、密码哈希：argon2（更现代的选择）

`argon2` 是目前主流推荐的密码哈希算法之一（比 bcrypt 新，抵抗 GPU 更好）。

### 1. 安装

```bash
npm i argon2
```

### 2. Service 封装示例

```ts
// crypto/argon2.service.ts
import { Injectable } from '@nestjs/common';
import * as argon2 from 'argon2';

@Injectable()
export class Argon2Service {
  async hash(plain: string): Promise<string> {
    return argon2.hash(plain, {
      type: argon2.argon2id, // 推荐 argon2id
      memoryCost: 2 ** 16,   // 可按机器性能调整
      timeCost: 3,
      parallelism: 1,
    });
  }

  async verify(hash: string, plain: string): Promise<boolean> {
    return argon2.verify(hash, plain);
  }
}
```

在用户服务中使用方法与上面的 `HashService` 类似，只是换成 argon2。

---

## 四、对称加密：使用 Node.js 原生 crypto（AES-GCM）

场景：你**必须**能解密，比如：

* 暂存银行卡号（不推荐长期存储，但有时业务需要）
* 保存第三方 API 的密钥（更推荐放到配置系统或 KMS）

### 1. 简单 AES-GCM 封装

```ts
// crypto/encryption.service.ts
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

@Injectable()
export class EncryptionService {
  // 256 bit key；实战中请从 env/ConfigService 中读取
  private readonly key = crypto
    .createHash('sha256')
    .update('some-very-strong-secret-key')
    .digest();

  private readonly algorithm = 'aes-256-gcm';

  encrypt(plaintext: string): string {
    // 12 字节随机 iv
    const iv = crypto.randomBytes(12);
    const cipher = crypto.createCipheriv(this.algorithm, this.key, iv);

    const encrypted = Buffer.concat([
      cipher.update(plaintext, 'utf8'),
      cipher.final(),
    ]);

    const authTag = cipher.getAuthTag();

    // 格式： iv:content:tag （base64）
    return [
      iv.toString('base64'),
      encrypted.toString('base64'),
      authTag.toString('base64'),
    ].join('.');
  }

  decrypt(ciphertext: string): string {
    const [ivStr, encryptedStr, authTagStr] = ciphertext.split('.');

    const iv = Buffer.from(ivStr, 'base64');
    const encrypted = Buffer.from(encryptedStr, 'base64');
    const authTag = Buffer.from(authTagStr, 'base64');

    const decipher = crypto.createDecipheriv(this.algorithm, this.key, iv);
    decipher.setAuthTag(authTag);

    const decrypted = Buffer.concat([
      decipher.update(encrypted),
      decipher.final(),
    ]);

    return decrypted.toString('utf8');
  }
}
```

### 2. 在业务中使用加密字段

例如：加密存储用户的“身份证号”：

```ts
// users/users.service.ts (节选)
import { EncryptionService } from '../crypto/encryption.service';

@Injectable()
export class UsersService {
  constructor(private readonly encryption: EncryptionService) {}

  async saveSensitive(idCard: string) {
    const enc = this.encryption.encrypt(idCard);
    // 存数据库的是 enc
    return enc;
  }

  async getSensitive(enc: string) {
    // 只有在确实需要展示时解密
    const plain = this.encryption.decrypt(enc);
    return plain;
  }
}
```

> 注意：能解密的东西一定要严格限制访问权限，配合授权体系一起做。

---

## 五、HMAC 签名：防篡改 / 第三方回调校验

场景：

* 第三方支付回调：对方用 secret 给 payload 做 HMAC，你用同一个 secret 校验
* 内部服务调用：在 header 中放签名，校验请求没有被篡改

### 1. 封装 HMAC Service

```ts
// crypto/hmac.service.ts
import { Injectable } from '@nestjs/common';
import * as crypto from 'crypto';

@Injectable()
export class HmacService {
  private readonly secret = 'hmac-shared-secret'; // 从 env 里拿

  sign(data: string): string {
    return crypto
      .createHmac('sha256', this.secret)
      .update(data, 'utf8')
      .digest('hex');
  }

  verify(data: string, signature: string): boolean {
    const expected = this.sign(data);
    // 防时序攻击，使用 timingSafeEqual 对比
    const a = Buffer.from(expected, 'hex');
    const b = Buffer.from(signature, 'hex');
    if (a.length !== b.length) return false;
    return crypto.timingSafeEqual(a, b);
  }
}
```

### 2. 在 Controller 里校验第三方回调签名

```ts
// payment/payment.controller.ts
import { Controller, Post, Headers, Body, BadRequestException } from '@nestjs/common';
import { HmacService } from '../crypto/hmac.service';

@Controller('payment')
export class PaymentController {
  constructor(private readonly hmacService: HmacService) {}

  @Post('notify')
  async handleNotify(
    @Headers('x-signature') signature: string,
    @Body() body: any,
  ) {
    const raw = JSON.stringify(body); // 实战中注意 raw body 一致性
    const ok = this.hmacService.verify(raw, signature);
    if (!ok) {
      throw new BadRequestException('签名不合法');
    }

    // TODO: 处理支付结果逻辑
    return { success: true };
  }
}
```

---

## 六、与 JWT 的关系：JWT 本身就包含“签名”

虽然你这次问的是加密 / 哈希，但常配合的是 JWT：

* JWT 使用 **哈希（如 HS256 = HMAC-SHA256）/ 非对称签名（RS256）** 来保证 token 没被篡改
* 我们在 AuthService 里使用 `JwtService` 时，其实底层已经在帮你做“签名 + 验证签名”

JWT 的 payload 自身不加密，只是 **签名**，所以里面不要放敏感的明文（比如完整银行卡号）。

---

## 七、如何“工程化”地组织这些加密/哈希功能

推荐的目录结构：

```text
src/
  crypto/
    hash.service.ts        // bcrypt 或 argon2 封装
    encryption.service.ts  // AES-GCM 封装
    hmac.service.ts        // HMAC 封装
    crypto.module.ts
  auth/
  users/
  ...
```

`crypto.module.ts`：

```ts
// crypto/crypto.module.ts
import { Module } from '@nestjs/common';
import { HashService } from './hash.service';
import { EncryptionService } from './encryption.service';
import { HmacService } from './hmac.service';

@Module({
  providers: [HashService, EncryptionService, HmacService],
  exports: [HashService, EncryptionService, HmacService],
})
export class CryptoModule {}
```

然后在 `AppModule` 或其他模块中 `imports: [CryptoModule]` 即可使用。

---

## 八、安全 & 实战注意事项总结

1. **密码只做哈希，不做对称加密**

   * 只要能解密，就一定会有人想办法拿明文
   * 用 bcrypt/argon2 这种专门的密码哈希算法

2. **所有秘钥都放在配置 / 环境变量**

   * 不要硬编码在 repo 里
   * 配合 `@nestjs/config` 使用

3. **加密算法选择**

   * 对称：AES-256-GCM（带认证，更安全）
   * 哈希：新项目推荐 argon2id，老项目兼容 bcrypt
   * HMAC：`HMAC-SHA256` 或更高

4. **不要自己设计“魔法加密算法”**

   * 直接用成熟库 + 推荐参数组合
   * 不要自己造轮子写复杂数学逻辑

5. **性能**

   * 哈希（尤其是 argon2/bcrypt）是有成本的，注册/登录接口要注意限流、避免并发爆炸
   * 可以通过 `saltRounds` / argon2 参数微调

---

如果你愿意，可以告诉我你现在具体的需求场景（比如“我要做用户密码存储 + 加密银行卡 + 校验支付回调”之类），我可以帮你把这些 Service 拼成一套完整、可直接用在你项目里的“加密 & 哈希方案配置”。
