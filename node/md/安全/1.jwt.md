下面我直接给你一个 **“NestJS + JWT 知识点 + 使用大全”**，配上**经典代码模板**，你照着抄+改变量名就能用。

---

## 一、几个核心概念先捋清

### 1. JWT 是啥

JWT（JSON Web Token）= 三段字符串：

1. Header：算法、类型（JWT）
2. Payload：你要塞的东西，比如 `sub`、`userId`、`role`
3. Signature：用 secret/私钥签出来的签名，防篡改

典型长这样：

```text
xxxxx.yyyyy.zzzzz
```

后端用 `secret` 签发，前端拿到后一般塞到：

* `Authorization: Bearer <token>` 头里
* 或者存 localStorage / cookie（注意安全问题）

---

### 2. Nest 里跟 JWT 强相关的几个包

* `@nestjs/jwt`：Nest 的 JWT 工具包，封装了 `jsonwebtoken` 的 `sign` / `verify` 等方法([GitHub][1])
* `@nestjs/passport`：把 Passport 策略整合进 Nest 守卫体系([NestJS 文档][2])
* `passport-jwt`：JWT 策略（`JwtStrategy`）

常见安装命令：

```bash
npm i @nestjs/jwt @nestjs/passport passport passport-jwt
npm i -D @types/passport-jwt
```

---

## 二、最经典的 JWT Auth 模块全家桶

我给你一个 **完整可跑的典型结构**（略简化），包括：

* `AuthModule`
* `AuthService`
* `JwtStrategy`
* `LocalStrategy`（用户名密码登录）
* `AuthController`
* `JwtAuthGuard` / `LocalAuthGuard`

目录大致：

```text
src/
  auth/
    auth.module.ts
    auth.service.ts
    auth.controller.ts
    jwt.strategy.ts
    local.strategy.ts
    guards/
      jwt-auth.guard.ts
      local-auth.guard.ts
  users/
    users.service.ts
  app.module.ts
```

### 1. AuthModule：配置 JwtModule + PassportModule

```ts
// auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './jwt.strategy';
import { LocalStrategy } from './local.strategy';

@Module({
  imports: [
    UsersModule,
    PassportModule, // 可设置 defaultStrategy: 'jwt'
    JwtModule.register({
      secret: 'hard-to-guess-secret', // 实际项目里别写死，放 env / ConfigModule
      signOptions: { expiresIn: '1h' },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  exports: [AuthService],
})
export class AuthModule {}
```

> 生产环境推荐 `JwtModule.registerAsync` + `ConfigService` 来动态读取 secret([GitHub][1])

---

### 2. UsersService：模拟一个用户服务（查用户）

```ts
// users/users.service.ts
import { Injectable } from '@nestjs/common';

export type User = any;

@Injectable()
export class UsersService {
  // 实际上应该查数据库
  private readonly users = [
    {
      userId: 1,
      username: 'john',
      password: 'changeme', // 应该是 hash 后的密码
      roles: ['user'],
    },
    {
      userId: 2,
      username: 'admin',
      password: 'admin',
      roles: ['admin'],
    },
  ];

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find((user) => user.username === username);
  }
}
```

---

### 3. AuthService：验证用户 + 签发 JWT

```ts
// auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { UsersService } from '../users/users.service';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  // 给 LocalStrategy 用的验证逻辑
  async validateUser(username: string, pass: string) {
    const user = await this.usersService.findOne(username);
    if (user && user.password === pass) {  // 实际项目要用 bcrypt compare
      const { password, ...result } = user;
      return result; // 不返回 password
    }
    return null;
  }

  // 登录成功后签发 token
  async login(user: any) {
    const payload = { username: user.username, sub: user.userId, roles: user.roles };
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}
```

> 官方文档里签发 token 也是类似结构：`sub` + `username` 等 payload([NestJS 文档][3])

---

### 4. LocalStrategy：用户名密码登录策略

```ts
// auth/local.strategy.ts
import { Strategy } from 'passport-local';
import { PassportStrategy } from '@nestjs/passport';
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { AuthService } from './auth.service';

@Injectable()
export class LocalStrategy extends PassportStrategy(Strategy) {
  constructor(private authService: AuthService) {
    super(); // 默认用户名字段是 'username'，密码 'password'
  }

  async validate(username: string, password: string): Promise<any> {
    const user = await this.authService.validateUser(username, password);
    if (!user) {
      throw new UnauthorizedException('用户名或密码错误');
    }
    return user; // 会挂到 req.user 上
  }
}
```

---

### 5. JwtStrategy：解析并验证 token

```ts
// auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // 从 Authorization: Bearer xxx
      ignoreExpiration: false, // false 时过期会自动抛错
      secretOrKey: 'hard-to-guess-secret', // 要和 JwtModule 里一致
    });
  }

  async validate(payload: any) {
    // 这里返回的内容会挂到 req.user
    return { userId: payload.sub, username: payload.username, roles: payload.roles };
  }
}
```

---

### 6. 守卫：LocalAuthGuard & JwtAuthGuard

```ts
// auth/guards/local-auth.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class LocalAuthGuard extends AuthGuard('local') {}
```

```ts
// auth/guards/jwt-auth.guard.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

---

### 7. AuthController：登录 + 获取当前用户

```ts
// auth/auth.controller.ts
import { Controller, Post, UseGuards, Request, Get } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LocalAuthGuard } from './guards/local-auth.guard';
import { JwtAuthGuard } from './guards/jwt-auth.guard';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  // 登录：用户名密码 -> access_token
  @UseGuards(LocalAuthGuard)
  @Post('login')
  async login(@Request() req) {
    return this.authService.login(req.user);
  }

  // 示例：需要携带 Bearer token 才能访问
  @UseGuards(JwtAuthGuard)
  @Get('profile')
  getProfile(@Request() req) {
    return req.user; // 就是 JwtStrategy.validate 返回的内容
  }
}
```

请求示例：

1. 登录：

```http
POST /auth/login
Content-Type: application/json

{
  "username": "john",
  "password": "changeme"
}
```

返回：

```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5..."
}
```

2. 携带 token 调用：

```http
GET /auth/profile
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5...
```

---

## 三、JwtService 常用 API & 实战技巧

`JwtService` 常用方法（底层用的是 `jsonwebtoken`）([GitHub][1])

```ts
this.jwtService.sign(payload, options?)
this.jwtService.signAsync(payload, options?)
this.jwtService.verify(token, options?)
this.jwtService.verifyAsync(token, options?)
this.jwtService.decode(token)
```

### 1. 常见用法

```ts
// 签发，覆盖默认 options
const token = this.jwtService.sign(
  { sub: user.id, username: user.username },
  { expiresIn: '2h' },
);

// 同步验证
try {
  const decoded = this.jwtService.verify(token);
} catch (e) {
  // TokenExpiredError / JsonWebTokenError ...
}
```

### 2. 密钥配置最佳实践

实际项目中推荐：

```ts
// auth.module.ts
import { ConfigModule, ConfigService } from '@nestjs/config';

@Module({
  imports: [
    ConfigModule.forRoot(),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: async (config: ConfigService) => ({
        secret: config.get<string>('JWT_SECRET'),
        signOptions: { expiresIn: config.get<string>('JWT_EXPIRES_IN') || '1h' },
      }),
      inject: [ConfigService],
    }),
  ],
})
export class AuthModule {}
```

---

## 四、在业务模块里使用 JWT 授权

### 1. 全局保护路由（所有路由默认需要 JWT）

```ts
// main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { JwtAuthGuard } from './auth/guards/jwt-auth.guard';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalGuards(new JwtAuthGuard() as any); // 若 guard 需要依赖注入需用 APP_GUARD 方式
  await app.listen(3000);
}
bootstrap();
```

更推荐用 `APP_GUARD` 注入：

```ts
// app.module.ts
import { APP_GUARD } from '@nestjs/core';
import { JwtAuthGuard } from './auth/guards/jwt-auth.guard';

providers: [
  {
    provide: APP_GUARD,
    useClass: JwtAuthGuard,
  },
],
```

然后在不需要鉴权的 controller 上单独加 `@Public()` 之类的自定义 metadata（略）。

---

### 2. 角色/权限控制（基于 JWT payload）

定义 `@Roles()` 装饰器 + `RolesGuard`：

```ts
// auth/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';
export const ROLES_KEY = 'roles';
export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

```ts
// auth/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from './roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(ctx: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(ROLES_KEY, [
      ctx.getHandler(),
      ctx.getClass(),
    ]);
    if (!requiredRoles) return true;

    const { user } = ctx.switchToHttp().getRequest();
    return requiredRoles.some((role) => user?.roles?.includes(role));
  }
}
```

应用到路由：

```ts
// some.module.controller.ts
import { Controller, Get, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/roles.guard';
import { Roles } from '../auth/roles.decorator';

@Controller('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
export class AdminController {
  @Get()
  @Roles('admin')
  findAll() {
    return '只有 admin 可以看';
  }
}
```

---

## 五、Refresh Token 典型写法（简版）

思路：

* access token：短有效期（15min ~ 1h）
* refresh token：长期有效期（7d/30d），存数据库/Redis，可随时失效

简化版代码（只展示核心逻辑）：

```ts
// auth/auth.service.ts (节选)
async login(user: any) {
  const payload = { sub: user.userId, username: user.username, roles: user.roles };
  const accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });
  const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

  // refreshToken 建议 hash 后存数据库
  await this.saveUserRefreshToken(user.userId, refreshToken);

  return { accessToken, refreshToken };
}

async refreshTokens(userId: number, refreshToken: string) {
  const user = await this.usersService.findById(userId);

  // 比对数据库里的 refreshToken（真实情况要 bcrypt 比对）
  if (!user || user.storedRefreshToken !== refreshToken) {
    throw new UnauthorizedException('Refresh token 无效');
  }

  try {
    const payload = await this.jwtService.verifyAsync(refreshToken);
    const newAccessToken = this.jwtService.sign(
      { sub: payload.sub, username: payload.username, roles: payload.roles },
      { expiresIn: '15m' },
    );
    return { accessToken: newAccessToken };
  } catch (e) {
    throw new UnauthorizedException('Refresh token 过期');
  }
}
```

Controller 示例：

```ts
// auth/auth.controller.ts
@Post('refresh')
async refresh(@Body() body: { userId: number; refreshToken: string }) {
  return this.authService.refreshTokens(body.userId, body.refreshToken);
}
```

---

## 六、常见坑 & 调试技巧

1. **401 一直返回 Unauthorized**

   * secret 不一致：`JwtModule` 的 secret 和 `JwtStrategy` 的 `secretOrKey` 必须一致([Stack Overflow][4])
   * token 没进来：检查请求头 `Authorization` 是否正确拼 Bearer
   * gateway / nginx 把 header 丢了：排查反向代理层([Stack Overflow][4])

2. **时区 & 过期问题**

   * `exp` 是 Unix 时间戳（秒），verify 会自动校验
   * 本机时间乱了也会导致“刚签发就过期”的假象

3. **不要把敏感信息塞进 payload**

   * 千万别放密码、银行卡完整号之类
   * JWT 是“可读但不可篡改”，不是“不可见”

4. **登出怎么做？**

   * JWT 本质无状态，没有“销毁 token”这种操作
   * 方案：

     * 改 secret：全员下线
     * 维护黑名单：在 Redis 标记失效 token
     * 用 refresh token 模式，通过旋转 refresh token 控制会话

---

## 七、如果你要“从 0 到 1”用 JWT 搭一套 auth

简单 checklist（照这个做基本不会错）：

1. `AuthModule` + `UsersModule` 搭好
2. 安装并配置 `@nestjs/jwt`、`@nestjs/passport`、`passport-jwt`
3. 写 `AuthService.validateUser` + `login`
4. 写 `LocalStrategy` + `JwtStrategy`
5. 写 `LocalAuthGuard` + `JwtAuthGuard`
6. `AuthController`:

   * `POST /auth/login`（LocalGuard）
   * `GET /auth/profile`（JwtGuard）
7. 前端拿 token 放 header，开始调保护接口
8. 进阶：增加 `RolesGuard`、Refresh Token、黑名单等

---

如果你愿意，可以把你现有的 `auth` 相关代码贴出来，我可以帮你**按上面的最佳实践改造/查 bug**，顺便给你做一版“你项目专属”的 JWT 模板。

[1]: https://github.com/nestjs/jwt?utm_source=chatgpt.com "nestjs/jwt: JWT utilities module based on the jsonwebtoken ..."
[2]: https://docs.nestjs.com/recipes/passport?utm_source=chatgpt.com "passport | NestJS - A progressive Node.js framework"
[3]: https://docs.nestjs.com/security/authentication?utm_source=chatgpt.com "Authentication | NestJS - A progressive Node.js framework"
[4]: https://stackoverflow.com/questions/55820591/nestjs-jwt-authentication-returns-401?utm_source=chatgpt.com "NestJs JWT Authentication returns 401"
