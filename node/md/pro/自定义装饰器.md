我直接用 **NestJS 项目里的“实战风格”** 给你讲自定义装饰器：什么是它、怎么写、放哪里、怎么配合 Guard / Pipe / Interceptor 一起玩。

---

## 一、先搞清：NestJS 里的“装饰器”是干嘛的？

一句话：**装饰器 = 给类/方法/参数/属性打元数据 + 做 AOP（切面逻辑）的入口**。

* Nest 本身的 `@Controller()`、`@Get()`、`@Injectable()` 都是装饰器。
* 自定义装饰器一般做两件事：

  1. **标记**：给类/方法/参数添加“标记信息”（元数据）。
  2. **被别的东西读取**：比如 Guard / Interceptor / Pipe / Filter 用 `Reflector` 读取这些元数据，然后根据这些标记做逻辑（鉴权、跳过登录、统一返回等）。

---

## 二、自定义装饰器常见三大类

1. **类/方法装饰器**：比如 `@Roles('admin')`、`@Public()`。
2. **参数装饰器**：比如 `@User()`、`@Ip()`。
3. （少用）**属性装饰器**：比如自定义给某个属性加特定 metadata。

下面我用项目目录 + 代码来讲。

---

## 三、类/方法装饰器：配合 Guard 使用（最常见）

### 场景例子：`@Roles('admin')` 做角色鉴权

**目录建议：**

```text
src/
  common/
    decorators/
      roles.decorator.ts
    guards/
      roles.guard.ts
```

### 1）定义自定义装饰器（`@Roles`）

```ts
// src/common/decorators/roles.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const ROLES_KEY = 'roles';

export const Roles = (...roles: string[]) => SetMetadata(ROLES_KEY, roles);
```

* `SetMetadata(key, value)`：给方法/类挂上 metadata。
* `ROLES_KEY` 是 key，roles array 是 value。
* 这是一个**方法装饰器 + 类装饰器**：可以用在 controller 类或具体 handler 上。

### 2）定义 Guard 读取这个装饰器

```ts
// src/common/guards/roles.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    // 先从 handler 再从 class 上取 metadata
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );
    if (!requiredRoles || requiredRoles.length === 0) {
      // 没标 @Roles 就不做限制
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const user = request.user; // 比如 JWT 验证过后挂在 req.user 上
    if (!user) return false;

    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```

### 3）在哪引入 & 怎么使用？

**全局引入（在 AppModule）：**

```ts
// src/app.module.ts
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { RolesGuard } from './common/guards/roles.guard';

@Module({
  providers: [
    {
      provide: APP_GUARD,
      useClass: RolesGuard,
    },
  ],
})
export class AppModule {}
```

**在 Controller 中使用：**

```ts
// src/modules/user/user.controller.ts
import { Controller, Get } from '@nestjs/common';
import { Roles } from 'src/common/decorators/roles.decorator';

@Controller('users')
export class UserController {
  @Get('admin-list')
  @Roles('admin') // 这里加上
  findOnlyAdminCanSee() {
    return 'only admin can see this';
  }
}
```

---

### 例子2：`@Public()` 标记“无需登录”的接口

```ts
// src/common/decorators/public.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
```

配合 JWT Auth Guard 使用：

```ts
// src/common/guards/jwt-auth.guard.ts
import { Injectable, ExecutionContext } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { Reflector } from '@nestjs/core';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(
      IS_PUBLIC_KEY,
      [context.getHandler(), context.getClass()],
    );
    if (isPublic) {
      // 标记了 @Public() 的接口，直接放行
      return true;
    }
    // 交给父类（真正做 JWT 校验）
    return super.canActivate(context);
  }
}
```

**在 Controller 使用：**

```ts
@Controller('auth')
export class AuthController {
  @Public()
  @Post('login')
  login(@Body() dto: LoginDto) {
    // 登录接口，无需携带 token
  }
}
```

---

## 四、参数装饰器：`@User()`、`@Ip()` 这种

参数装饰器非常常用，尤其是获取 `req.xxx`。

### 核心 API：`createParamDecorator`

```ts
// src/common/decorators/user.decorator.ts
import {
  createParamDecorator,
  ExecutionContext,
} from '@nestjs/common';

export const User = createParamDecorator(
  (data: string | undefined, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    const user = request.user;

    // @User()        => 返回 user 整个对象
    // @User('id')    => 返回 user.id
    return data ? user?.[data] : user;
  },
);
```

### 使用方式：

```ts
// src/modules/user/user.controller.ts
import { Controller, Get } from '@nestjs/common';
import { User } from 'src/common/decorators/user.decorator';

@Controller('profile')
export class ProfileController {
  @Get()
  getProfile(@User() user: any) {
    return user;
  }

  @Get('id')
  getUserId(@User('id') userId: number) {
    return { userId };
  }
}
```

> **在哪引入？**
>
> * 自定义参数装饰器文件一般放在：`src/common/decorators/` 下。
> * 控制器文件中直接 `import { User } from 'src/common/decorators/user.decorator';` 然后用在参数上。

---

### 再举一个：获取客户端 IP 的装饰器

```ts
// src/common/decorators/ip.decorator.ts
import {
  createParamDecorator,
  ExecutionContext,
} from '@nestjs/common';

export const ClientIp = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return (
      request.ip ||
      request.headers['x-forwarded-for'] ||
      request.connection.remoteAddress
    );
  },
);
```

使用：

```ts
@Get('log')
log(@ClientIp() ip: string) {
  console.log('client ip:', ip);
  return { ip };
}
```

---

## 五、（了解即可）属性装饰器

比如你想在实体/DTO 的某个属性上加个标记，在运行时通过反射读取它。

```ts
// src/common/decorators/searchable.decorator.ts
import 'reflect-metadata';

const SEARCHABLE_KEY = 'isSearchable';

export function Searchable(): PropertyDecorator {
  return (target, propertyKey) => {
    Reflect.defineMetadata(SEARCHABLE_KEY, true, target, propertyKey);
  };
}

export function isSearchable(target: any, propertyKey: string) {
  return Reflect.getMetadata(SEARCHABLE_KEY, target, propertyKey);
}
```

使用在 DTO 或 Entity：

```ts
export class UserEntity {
  @Searchable()
  username: string;

  password: string;
}
```

然后在某个 service 里可以遍历属性，找哪些字段 `isSearchable === true` 来构建搜索条件（这个比较进阶，了解有这么个用法就行）。

---

## 六、小结：自定义装饰器怎么规划在项目里？

**推荐目录结构：**

```text
src/
  common/
    decorators/
      roles.decorator.ts      // @Roles()
      public.decorator.ts     // @Public()
      user.decorator.ts       // @User()
      ip.decorator.ts         // @ClientIp()
      ...
    guards/
      roles.guard.ts
      jwt-auth.guard.ts
    interceptors/
    pipes/
    filters/
```

**使用原则：**

* 所有会被 Guard / Interceptor / Filter / Pipe 读取的**标记类装饰器**都用 `SetMetadata` 实现。
* 所有从 `req`/`res` 获取信息的都用 `createParamDecorator` 实现。
* Controller / Service 中只负责 `import` 对应装饰器，然后在类/方法/参数上使用即可。

---

如果你愿意，我可以帮你基于一个简单的登录鉴权项目，把：

* `@Public`
* `@Roles`
* `@User`

这三个自定义装饰器 **从零到整套 Guard + Controller 代码串起来**，你一看就能懂整个调用链。
