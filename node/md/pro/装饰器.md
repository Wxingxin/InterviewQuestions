下面这一份，就是把 **NestJS 中“装饰器（Decorator）”** 从“是什么 → 有什么用 → 在哪里用 → 项目中如何用”全部讲清楚的完整版知识体系。
内容不会东一块西一块，而是像一个“语法显微镜”，让你真正理解装饰器的底层逻辑与在 NestJS 中的意义。

---

# 🌙 一、什么是装饰器？（本质定义）

在 NestJS 中（以及 TypeScript 中），

> **装饰器是一种“为类、方法、参数、属性添加元数据（Metadata）”的语法糖。**

你可以把它理解为：

* **为某个东西“贴标签”**
* 提供给 NestJS 用的 **元信息（Metadata）**
* NestJS 根据这些元信息完成自动路由、依赖注入、pipeline 管道等行为

举例：

```ts
@Controller('user')
class UserController {}
```

这里的 `@Controller('user')` 就是一个装饰器，它告诉 Nest：

> “这个类是一个控制器，并且它的路由前缀是 /user”

**装饰器 = Nest 的语言规范，是框架自动化的核心。**

---

# 🌟 二、装饰器有什么用？（作用体系）

NestJS 的所有能力都来自装饰器。
它们能告诉框架：

* **这个类是什么角色**（Controller、Module、Injectable…）
* **这个方法是什么路由**（GET、POST…）
* **这个参数要从哪里取**（Body、Param、Query…）
* **这个 Provider 要注入什么依赖**（Inject）
* **这个管道/拦截器/守卫要作用在哪里**

总而言之：

> **装饰器是 NestJS 的“元数据系统”。
> 没有它，Nest 无法知道你写的类要干嘛。**

---

# 🧭 三、装饰器在哪里使用？（核心位置）

装饰器分为“4 大类型”，每类对应 Nest 的 4 种“挂载方式”。

---

# 🧩 Ⅰ. 类装饰器（Class Decorator）

👉 用来定义类的“身份”。

最常见：

### ✔ `@Controller()`

用于声明控制器及路由前缀：

```ts
@Controller('user')
export class UserController {}
```

### ✔ `@Module()`

用于定义模块：

```ts
@Module({
  imports: [],
  providers: [],
})
export class UserModule {}
```

### ✔ `@Injectable()`

定义一个 provider，可被注入：

```ts
@Injectable()
export class UserService {}
```

### ✔ `@Global()`

声明全局模块：

```ts
@Global()
@Module({...})
export class ConfigModule {}
```

---

# 🧩 Ⅱ. 方法装饰器（Method Decorator）

👉 用来定义路由或生命周期函数。

最常见：

### ✔ 路由相关：

```ts
@Get()
@Post()
@Put(':id')
@Delete(':id')
```

```ts
@Get('detail/:id')
getDetail() {}
```

### ✔ `@UseGuards()`、`@UseInterceptors()`、`@UsePipes()`

```ts
@UseGuards(AuthGuard)
@Get()
findAll() {}
```

### ✔ 异常过滤器

```ts
@UseFilters(HttpExceptionFilter)
```

---

# 🧩 Ⅲ. 参数装饰器（Parameter Decorator）

👉 用来告诉 Nest “参数来自哪里”。

比如：

```ts
@Get(':id')
getUser(
  @Param('id') id: number,
  @Query('page') page: number,
  @Body() dto: UserDto,
  @Headers('token') token: string,
  @Req() req,
  @Res() res,
) {}
```

最常用：

* `@Param()`
* `@Body()`
* `@Query()`
* `@Headers()`
* `@Req()`
* `@Res()`
* `@Session()`
* `@Ip()`

这些让你轻松从 HTTP 中获取信息，而无需做繁琐解析。

---

# 🧩 Ⅳ. 属性装饰器（Property Decorator）

👉 用在类的属性上，用得较少，但也很关键：

例如：

```ts
@Injectable()
export class UserService {
  @Logger()
  private readonly logger;
}
```

TypeORM 中 Entity 也是大量用属性装饰器：

```ts
@Entity()
class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;
}
```

这里的 @Column、@Entity 都是属性/类装饰器。

---

# 🔥 四、装饰器的底层原理是什么？（深度理解）

装饰器通过 **Reflect Metadata** 存储元数据：

```ts
Reflect.defineMetadata(key, value, target)
Reflect.getMetadata(key, target)
```

NestJS 在运行时会读取这些元数据，做成一条“执行链”。

例如：

```
@Controller('user')
 → 标记这是控制器

@Get(':id')
 → 标记这是 GET /user/:id 的 handler

@Param('id')
 → 告诉 handler 的参数如何映射

@UseGuards(AuthGuard)
 → 加到 pipeline

所有元数据最终构成一个可执行管道 → Nest 调用 pipeline → 然后执行 handler
```

装饰器的意义就是：
**让 Nest 通过元数据自动构建一个完整的“请求生命周期”。**

---

# 🧠 五、装饰器在项目体系中的作用（结合真实业务）

我们以“User 模块”为例：

```
src/
  user/
    user.module.ts
    user.controller.ts
    user.service.ts
    user.entity.ts
```

你会看到所有装饰器贯穿整个模块：

---

## 🟢 user.module.ts

```ts
@Module({
  controllers: [UserController],
  providers: [UserService],
})
export class UserModule {}
```

@Module 声明模块结构。

---

## 🟣 user.service.ts

```ts
@Injectable()
export class UserService {}
```

Injectable 让它能被注入。

---

## 🔵 user.controller.ts

```ts
@Controller('user')
export class UserController {
  constructor(private readonly userService: UserService) {}

  @Get(':id')
  get(@Param('id', ParseIntPipe) id: number) {
    return this.userService.findOne(id);
  }

  @Post()
  create(@Body() dto: CreateUserDto) {}
}
```

Controller + Http Method + Params = HTTP 路由系统完全由装饰器驱动。

---

## 🟡 user.entity.ts（TypeORM）

```ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  name: string;
}
```

TypeORM 也靠装饰器映射数据库表。

---

# 🧩 六、自定义装饰器（高级用法）

NestJS 支持自定义装饰器：

## 1）自定义参数装饰器

例如创建 @User() 获取当前请求用户：

```ts
export const User = createParamDecorator((data, ctx) => {
  const request = ctx.switchToHttp().getRequest();
  return request.user;
});
```

使用：

```ts
@Get()
getProfile(@User() user) {
  return user;
}
```

---

## 2）自定义类装饰器（高级）

例如创建一个 @Role() 来标记控制权限：

```ts
export const Role = (role: string) => SetMetadata('role', role);
```

使用：

```ts
@Role('admin')
@Get()
findAll() {}
```

Guard 可以读取这个 metadata 做权限判断。

---

# 🎯 七、装饰器的最终价值（一句话总结）

> **装饰器让 NestJS 成为一个“元编程框架”：
> 我们通过修饰代码结构，Nest 自动推导出整个运行管线。**

它带来的好处：

* 极高的可读性
* 自动化路由与 DI
* 不需要手写脚手架代码
* 更少的模板代码（boilerplate）
* 代码结构更清晰
* 扩展性更强

装饰器是 NestJS 的绝对核心。

---

# 📌 八、面试/复习速记版

```
装饰器 = 给类/方法/属性/参数打标签的语法糖
        用来为 NestJS 注入元数据（Metadata）

分类：4 类
  1. 类装饰器：@Controller @Module @Injectable @Global
  2. 方法装饰器：@Get @Post @UseGuards @UsePipes @UseInterceptors
  3. 参数装饰器：@Body @Query @Param @Headers @Req
  4. 属性装饰器：@Column @Inject @PrimaryGeneratedColumn

作用：
  标记框架角色、声明路由、绑定参数、声明依赖注入

使用位置：
  Module、Controller、Service、Entity、Guard、Pipe、Filter、Interceptor

底层原理：
  Reflect Metadata + Nest 构建执行管线

项目价值：
  自动化、可读、结构化、模块化、可拓展
```

---

如果你愿意，我还能继续帮你：

### ✓ 画出“装饰器如何构建 Nest 生命周期管线”的流程图

### ✓ 教你手写一个 @Controller 装饰器（深度源码理解）

### ✓ 给出“自定义装饰器最佳实践大全”（项目级）

想继续哪一块？
