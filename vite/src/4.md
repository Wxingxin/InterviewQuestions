好，既然你把这段单独拎出来了，我就按你列的知识点，给你做一份「Vite 生产环境构建详解 + 实战操作手册」，你照着练 2～3 天就能比较熟。

---

## 一、`npm run build` 到底干了什么？

在 Vite 项目里，`npm run build` 一般是：

```jsonc
// package.json
{
  "scripts": {
    "build": "vite build"
  }
}
```

执行流程（简化版）：([vitejs][1])

1. 读取 `vite.config.*` 配置
2. 把开发时那套“按需加载的 ESM 模块”交给 **Rollup** 进行打包
3. Rollup 负责：

   * 分析依赖图（依赖关系）
   * 做 **Tree Shaking**、**代码分割**
   * 产出若干 JS/CSS/静态资源文件
4. 根据 `build.minify` 等配置做压缩、生成 source map 等
5. 最终产物输出到 `build.outDir`（默认 `dist`）

> 小结：
>
> * 开发：Vite 自己的 Dev Server + ES Modules
> * 构建：Vite 调用 Rollup 做传统打包优化

---

## 二、Rollup 打包流程（Vite 版概念图）

Vite 构建时其实就是给 Rollup 喂了一堆“已经处理好了的模块”，再加上一些内置插件。([vitejs][1])

可以这样理解：

1. **入口**：从 `index.html` 里 `<script type="module" src="/src/main.ts">` 作为入口
2. **依赖图**：顺着 `import` 把所有依赖模块拉进来，形成一张依赖图
3. **插件链**：Vite + Rollup 插件在这个过程中不断处理文件（TS->JS、Vue SFC->JS、CSS 处理等等）
4. **代码分割**：根据同步/异步模块、动态 import、`manualChunks` 策略拆成多个 chunk
5. **Tree Shaking**：剔除没用到的导出（基于 ES Modules 静态分析）
6. **生成产物**：输出 JS/CSS/静态资源到 `dist`，并写好 HTML 里的 `<script src="...">`

你不必死记 Rollup 的所有配置，但要知道：

> **Vite 的 `build.rollupOptions` 就是你对打包流程的“后门控制面板”。**

---

## 三、代码分割（Split Chunks）怎么做？

### 1. 默认代码分割（自动）

只要你用到了 **动态 import**，Vite 就会自动把被动态加载的模块拆成独立 chunk：([vitejs][1])

```ts
// 路由懒加载示例（Vue Router）
const UserPage = () => import('@/pages/UserPage.vue')
```

上面这一行会让 `UserPage` 对应的代码被单独打成一个 JS 文件，只有访问到这个路由时才会被加载。

默认情况下，Vite / Rollup 会智能地按照依赖关系拆包，一般不需要你手动干预。

---

### 2. 手动代码分割（`manualChunks`）

当你想要“更细粒度”地控制拆包方式（比如统一拆出一个 `vendor` 包）时，可以用：([vitejs][1])

```ts
// vite.config.ts
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    rollupOptions: {
      output: {
        manualChunks(id) {
          // 所有 node_modules 里的东西打到一个 vendor.js 里
          if (id.includes('node_modules')) {
            return 'vendor'
          }
        },
      },
    },
  },
})
```

也可以按业务切：

```ts
manualChunks(id) {
  if (id.includes('node_modules')) return 'vendor'
  if (id.includes('/src/views/admin/')) return 'admin'
}
```

**什么时候要动 `manualChunks`？**

* 你的首屏 JS 很大，想拆分 vendor/某些大模块
* SSR / Electron / 多页面应用，需要更精细控制构建产物

---

## 四、Tree Shaking：怎么让无用代码被“抖掉”？

Tree Shaking 的目标：**删掉你没用到的代码**，减小 bundle 体积。([mollify.noroff.dev][2])

Vite + Rollup 是基于 ES Modules 来做 Tree Shaking 的：

1. **前提条件**

   * 代码使用 `import/export`，而不是 `require()`
   * 依赖包也最好提供 `module`/`exports` 为 ES Module 版本

2. **实战建议**

   * 尽量使用 ES 模块版本的库，比如 `lodash-es`：

     ```ts
     import { debounce } from 'lodash-es'
     ```
   * 避免那种“把库全引入再挂到全局”的写法
   * 若你写的是库，要在 `package.json` 的 `sideEffects` 标好哪些文件有副作用

3. **怎么验证 Tree Shaking 是否生效？**

   * 用 `rollup-plugin-visualizer` 看某个大库是不是只被打包了部分代码
   * 看打包产物里是否存在你明明没用到的模块内容

---

## 五、静态资源处理（图片 / CSS / 字体等）

Vite 对静态资源的处理大致有两类：([vitejs][3])

### 1. `src` 内通过 `import` 引用的资源

```ts
import logo from '@/assets/logo.png'
```

* 构建时会：

  * 把图片复制到 `dist/assets/` 下
  * 文件名加 hash：`logo.8f3b2a4.png`
  * 代码中 `logo` 变量会被替换成最终 URL

相关配置：

```ts
build: {
  assetsInlineLimit: 4096, // 小于 4KB 的资源会被转成 base64 内联
  assetsDir: 'assets',     // 静态资源目录
}
```

CSS / 字体文件等也按类似规则处理。

---

### 2. `public` 目录下的资源

* 原样拷贝到 `dist` 根目录，不会加 hash 名。
* 在代码里通过绝对路径访问：`/some-file.png`

适合放：

* 第三方库、CDN 替代不了的大文件
* manifest、robots.txt 等必须固定路径的文件

---

## 六、构建优化关键配置

### 1. `build.minify` – 压缩方式

```ts
build: {
  minify: 'esbuild', // 默认
  // minify: 'terser',
  // minify: false,
}
```

* `esbuild`（默认）：极快，压缩率略逊于 Terser，但多数项目够用。([vitejs][3])
* `terser`：更高压缩率，尤其是对复杂压缩选项；但构建更慢。
* `false`：不压缩，一般只用于调试 / CI 分析。

**建议：**

* 90% 项目用默认 `esbuild`。
* 极致体积要求（比如低网速场景）可以尝试 `terser`，要权衡时间。

---

### 2. `build.sourcemap` – 是否生成 Source Map

```ts
build: {
  sourcemap: false,    // 默认
  // sourcemap: true, // 独立 .map 文件
  // sourcemap: 'inline',
}
```

* 开 `true` 的优点：

  * 线上错误堆栈能指回源码
  * 便于排查线上 bug
* 缺点：

  * 打包时间略长
  * 产物体积变大（多出 map 文件）

**常见实践：**

* 正式生产环境：

  * 中小项目：`sourcemap: false`（更简单）
  * 大前端团队：`sourcemap: true`，同时在 Sentry / 日志平台上传 source map

---

### 3. `build.dynamicImportVars` – 动态 import 的处理

当你写类似这样的代码时：([vitejs][3])

```ts
const page = await import(`./pages/${name}.ts`)
```

这叫 **dynamic import variables**。打包时需要静态分析可能的路径范围，不然 Rollup 不知道要打哪些文件进这个 chunk。

Vite 提供 `build.dynamicImportVarsOptions`（在新文档里属于高级配置），一般情况：

* 尽量让动态路径“可被推断”，例如限制目录、后缀
* 若写成太动态的表达式，可能会把整个目录都打进去（包太大）

给你的经验法则是：**动态 import 尽量写成简单的模板字符串，目录固定、后缀固定**。

---

### 4. gzip / brotli 压缩

Vite 打包出来是未压缩的 `.js` / `.css` 文件，**真实线上 gzip/brotli 压缩通常由服务器或 CDN 做**（Nginx / Cloudflare / Vercel 等）。([mollify.noroff.dev][2])

如果你是自己部署静态文件，有两种做法：

1. 服务器层配置（推荐）

   * Nginx/Apache/Tengine 等开启 gzip/brotli 模块

2. 构建时生成 `.gz` / `.br` 文件：使用插件

   * 例如：`vite-plugin-compression`（可生成 `xxx.js.gz` / `xxx.js.br`）
   * 你再在服务器配置里，让它优先返回压缩后的文件

示例（使用 gzip）：

```ts
// vite.config.ts
import viteCompression from 'vite-plugin-compression'

export default defineConfig({
  plugins: [
    viteCompression({
      algorithm: 'gzip',
      threshold: 10240, // 只压 10KB 以上的文件
    }),
  ],
})
```

---

## 七、构建产物分析：看清楚你的包长什么样

### 1. `vite build --debug`

你可以运行：

```bash
npx vite build --debug
```

它会输出更详细的日志（插件执行、打包阶段等），适合你排查“为什么构建慢”。

---

### 2. 使用 `rollup-plugin-visualizer` 看包体积构成

步骤：([DEV Community][4])

1. 安装插件：

   ```bash
   npm i -D rollup-plugin-visualizer
   ```

2. 在 `vite.config` 里加入：

   ```ts
   // vite.config.ts
   import { defineConfig } from 'vite'
   import { visualizer } from 'rollup-plugin-visualizer'

   export default defineConfig({
     build: {
       rollupOptions: {
         plugins: [
           visualizer({
             filename: 'dist/stats.html',
             gzipSize: true,
             brotliSize: true,
           }),
         ],
       },
     },
   })
   ```

3. 重新打包：

   ```bash
   npm run build
   ```

4. 打开 `dist/stats.html`，你就能看到每个 chunk / 每个依赖占了多大，最适合用来找“大胖子”库。

---

## 八、照着练的「2～3 天实战计划」

你可以干脆按这个节奏来：

### Day 1：基础构建 & 查看产物

1. 在自己项目里跑：`npm run build`
2. 浏览 `dist/` 目录，搞清楚：

   * 哪个是入口 HTML
   * JS/CSS 文件是如何命名的（带 hash）
   * 图片/字体等放在哪里
3. 尝试改动：

   * `build.outDir`、`build.assetsDir`，再 build 看效果

---

### Day 2：代码分割 & Tree Shaking 实战

1. 找一个页面路由，改成动态 import，看是否多出一个 chunk
2. 引入一个大库（如 `lodash-es`），分别用：

   * `import _ from 'lodash-es'`
   * `import { debounce } from 'lodash-es'`
3. 用 `rollup-plugin-visualizer` 对比两种写法的构建体积差异

---

### Day 3：优化 & 压缩

1. 开关 `build.sourcemap`、`build.minify`：

   * 比较构建耗时和 `dist/` 体积
2. 加上 gzip 插件，生成 `.gz` 文件
3. 按 `visualizer` 图调整：

   * 把某些模块改成懒加载（动态 import）
   * 或者使用 `manualChunks` 拆出 `vendor`

---

如果你愿意，可以把你现在的 `vite.config` 贴出来，我可以直接在你项目的场景上给你做一版**针对性的生产构建优化方案（含代码分割/压缩/分析配置）**，这样会更落地。

[1]: https://vite.dev/guide/build?utm_source=chatgpt.com "Building for Production"
[2]: https://mollify.noroff.dev/content/feu2/javascript-2/module-3/vite/vite-build-process?utm_source=chatgpt.com "Vite Build Process | Mollify LMS"
[3]: https://vite.dev/config/build-options?utm_source=chatgpt.com "Build Options"
[4]: https://dev.to/perisicnikola37/optimize-vite-build-time-a-comprehensive-guide-4c99?utm_source=chatgpt.com "Optimize Vite Build Time: A Comprehensive Guide"
