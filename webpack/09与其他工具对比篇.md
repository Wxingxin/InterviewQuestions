这组题属于 **Webpack 与现代构建工具对比与发展趋势**，面试主要考察你对前端生态变化、性能优化工具链的理解，以及迁移方案。下面逐题详细解析：

---

## **1️⃣ Webpack vs Vite 的区别？**

| 特性   | Webpack       | Vite                     |
| ---- | ------------- | ------------------------ |
| 构建方式 | 传统打包，先打包整个项目  | 原生 ESM + 按需编译，开发环境即时服务   |
| 启动速度 | 慢，首次构建需打包所有模块 | 快，直接利用浏览器 ESM 解析模块       |
| 热更新  | HMR 需要打包更新模块  | HMR 基于原生 ESM，速度快，状态保持    |
| 插件生态 | 丰富，成熟         | 较新，但 Vite 插件兼容 Rollup 插件 |
| 生产构建 | bundle 输出     | 内部使用 Rollup 打包输出         |

✅ 面试要点：Webpack 灵活且成熟，Vite 更注重开发体验和启动速度。

---

## **2️⃣ Webpack vs Rollup 的区别？**

| 特性           | Webpack             | Rollup                    |
| ------------ | ------------------- | ------------------------- |
| 目标           | 应用程序（SPA）           | 库 / 小模块                   |
| 模块类型         | 支持 CJS、ESM、AMD      | 主要支持 ESM                  |
| Tree Shaking | 支持，但需注意 sideEffects | Tree Shaking 更高效，天然支持 ESM |
| 插件生态         | 丰富，复杂               | 轻量，专注打包库                  |
| 输出           | 多 Chunk             | 通常单文件输出，适合库打包             |

---

## **3️⃣ 为什么 Webpack 构建慢，而 Vite 快？**

* Webpack：**整个项目一次性打包**，需处理 loader、plugin、模块依赖图 → 首次构建慢
* Vite：**利用浏览器原生 ESM 按需加载模块**，仅访问的模块才编译 → 启动快
* Webpack HMR：每次修改需重新编译模块，速度受 bundle 大小影响
* Vite HMR：模块级更新，无需重打包全局 bundle

---

## **4️⃣ Webpack 与 esbuild 的关系？**

* esbuild 是用 Go 编写的极快打包/转译工具
* Webpack 可以使用 esbuild 替代部分 loader：

  * `esbuild-loader` 替换 `babel-loader`
  * `esbuild-plugin` 替代 TerserPlugin
* 优点：大幅提升构建和压缩速度
* Webpack 本身仍负责依赖图和插件体系，esbuild 仅替代其中的编译步骤

---

## **5️⃣ Webpack 如何与 SWC 配合使用？**

* SWC 是 Rust 实现的高速 JS/TS 编译器
* 可以替代 Babel：

```bash
npm install swc-loader @swc/core -D
```

```js
module: {
  rules: [
    {
      test: /\.(js|ts|jsx|tsx)$/,
      loader: 'swc-loader',
      options: {
        jsc: {
          parser: { syntax: 'typescript', jsx: true },
          target: 'es2022'
        }
      }
    }
  ]
}
```

* 优势：编译速度比 Babel 高 10~30 倍

---

## **6️⃣ Webpack5 相比 Webpack4 有哪些变化？**

1. **持久化缓存**（Filesystem Cache）
2. **Module Federation** 原生支持微前端
3. **原生 ESM 输出与实验性支持**
4. **废弃了 `CommonsChunkPlugin`** → 使用 `SplitChunksPlugin`
5. **asset module** 代替 file-loader/url-loader/raw-loader
6. **Tree Shaking 默认支持**
7. 内置 `optimization.runtimeChunk: 'single'` 提升缓存效率

---

## **7️⃣ Webpack5 的 Module Federation 是什么？**

* **微前端解决方案**
* 可以在不同 Webpack 构建的应用间共享模块
* 特点：

  * 共享依赖（react/vue 等）
  * 动态加载远程模块（remoteEntry.js）
  * 独立部署、按需加载
* 面试示意：

```js
new ModuleFederationPlugin({
  name: 'app1',
  remotes: { app2: 'app2@http://localhost:3002/remoteEntry.js' },
  shared: ['react', 'react-dom']
});
```

---

## **8️⃣ Webpack 可以被替代吗？**

* 在现代前端应用中，Webpack 依然成熟且功能全面
* 对于开发体验要求高的小项目 → 可用 Vite / Snowpack / ESBuild 替代
* Webpack 优势：

  * 强大的 Loader/Plugin 生态
  * 完整构建生命周期
  * 可扩展性强，适合大型复杂应用

---

## **9️⃣ 如何从 Webpack 迁移到 Vite？**

1. **调整入口文件**
2. **安装 Vite**：

```bash
npm install vite @vitejs/plugin-react -D
```

3. **替换 Loader 配置** → Vite 使用原生 ESM + 插件
4. **替换 HMR/环境变量**
5. **调整生产构建配置** → Vite 内部使用 Rollup
6. **测试依赖兼容性** → 部分 Webpack 特性可能需修改

---

## **🔟 Webpack 在现代前端中的定位是什么？**

* **大型企业级项目依然首选**，尤其是：

  * 多入口 SPA
  * 微前端
  * 自定义构建需求
* **核心优势**：

  * 灵活可扩展的 Loader/Plugin
  * 强大的优化策略（Code Splitting、Tree Shaking、持久化缓存）
* **趋势**：

  * 与 Vite、ESBuild、SWC 配合，提高速度
  * 保持在复杂项目和微前端场景的主力地位

---

### 🔑 面试总结

* Webpack 适合复杂、大型项目
* Vite/esbuild 适合中小型项目和快速开发
* Webpack5 新特性（Module Federation、持久化缓存、asset modules）提升现代应用能力
* 面试可结合性能对比 + 微前端 + 迁移经验回答

---

我可以帮你把 **前面五套 Webpack 面试题（共 160+ 道）** 整理成一本 **《Webpack 全套面试精讲 PDF》**：

* 按章节划分：

  1. 原理篇（模块加载、HMR、Tree Shaking）
  2. 配置篇（Loader/Plugin/样式/静态资源）
  3. 优化篇（体积、速度、缓存、gzip）
  4. 进阶篇（SSR、微前端、Module Federation、迁移、趋势）
* 配置示例 + 图解 + 面试要点

你希望我帮你排版导出吗？
