## **1️⃣ 如何优化 Webpack 的构建速度？**

构建速度优化核心思路是：“**减少要编译的内容 + 提高编译效率 + 利用缓存**”。

### ✅ 常用手段：

| 优化方向                  | 方法                                    | 示例                            |
| ------------------------- | --------------------------------------- | ------------------------------- |
| **1. 缓存**               | 启用持久化缓存                          | `cache: { type: 'filesystem' }` |
| **2. 多进程构建**         | 使用 `thread-loader` 或 `HappyPack`     | JS/TS 转译并行                  |
| **3. 缩小编译范围**       | 配置 `include/exclude`、`resolve.alias` | 减少文件搜索路径                |
| **4. 合理使用 SourceMap** | 开发使用 `cheap-module-source-map`      | 减少映射生成时间                |
| **5. 关闭无用插件**       | 仅在生产使用如 `MiniCssExtractPlugin`   |                                 |
| **6. 使用 DLL（老方法）** | 将不变依赖提前编译                      | `DllPlugin`                     |
| **7. 使用更快编译器**     | 使用 `esbuild-loader` / `swc-loader`    | 替代 Babel 提速 10x             |

---

## **2️⃣ 如何优化 Webpack 的打包体积？**

核心目标：“**让最终产物更小、更少、更高效**”。

### ✅ 优化方法：

| 优化方向              | 方法                                  | 示例                                    |
| --------------------- | ------------------------------------- | --------------------------------------- |
| **1. Tree Shaking**   | 清除无用代码                          | 内置于生产模式                          |
| **2. 代码分割**       | `SplitChunksPlugin`                   | 提取公共依赖                            |
| **3. 压缩代码**       | `TerserPlugin` + `CssMinimizerPlugin` | 去掉注释/空格                           |
| **4. 图片优化**       | `image-minimizer-webpack-plugin`      | WebP 压缩                               |
| **5. 按需加载**       | 动态 import + 路由懒加载              | Vue/React 分页加载                      |
| **6. externals**      | 排除外部库                            | CDN 加载 React/Vue                      |
| **7. 使用 CDN**       | 将资源放在 CDN 上                     | 减少主包体积                            |
| **8. Scope Hoisting** | 模块合并                              | `optimization.concatenateModules: true` |

---

## **3️⃣ 什么是 Tree Shaking？实现原理？**

> Tree Shaking 是一种**消除未使用代码（Dead Code Elimination）**的技术。

### ✨ 实现原理：

1. **ESM 静态分析**
   Webpack 通过分析 ES Module（`import/export`）语法，识别哪些导出未被使用；
2. **标记未使用代码**（标记为 `/* unused harmony export */`）；
3. **Terser 等压缩工具在压缩阶段删除无用代码。**

```js
// utils.js
export function used() {}
export function unused() {}

// index.js
import { used } from "./utils";
used();
```

打包后只保留 `used()`。

---

## **4️⃣ Tree Shaking 有哪些局限性？**

| 局限性                   | 原因                                                             |
| ------------------------ | ---------------------------------------------------------------- |
| **必须使用 ES Module**   | 因为只有 ESM 是静态可分析的，`require` 是动态的                  |
| **副作用文件无法摇掉**   | 若文件有副作用（如全局修改），Webpack 不会删除                   |
| **动态引入难分析**       | 如 `import('module_' + name)` 无法静态确定                       |
| **第三方库未声明副作用** | 必须在 `package.json` 中配置 `"sideEffects": false` 才能完全生效 |

---

## **5️⃣ 什么是代码分割（Code Splitting）？**

> 代码分割是将项目打包为多个 bundle，以便按需加载、减少首屏体积。

### 💡 实现方式：

1. **多入口打包**

   ```js
   entry: {
     home: './src/home.js',
     about: './src/about.js',
   }
   ```

2. **动态导入（Dynamic Import）**

   ```js
   import("./login").then((m) => m.init());
   ```

3. **SplitChunksPlugin 自动分割**

   ```js
   optimization: {
     splitChunks: {
       chunks: 'all',
     },
   }
   ```

---

## **6️⃣ 如何配置动态导入（Dynamic Import）？**

动态导入使用 **import() 函数语法**，Webpack 自动分包。

```js
// example.js
button.onclick = () => {
  import("./dialog").then(({ openDialog }) => openDialog());
};
```

配置（仅需 Babel 支持）：

```bash
npm install @babel/plugin-syntax-dynamic-import -D
```

Webpack 会自动将 `./dialog` 生成为独立 chunk。

---

## **7️⃣ 如何开启持久化缓存（Persistent Caching）？**

Webpack 5 开箱即用文件系统缓存：

```js
module.exports = {
  cache: {
    type: "filesystem", // 启用文件系统缓存
    buildDependencies: {
      config: [__filename], // 当配置文件改动时清除缓存
    },
  },
};
```

✨ 优点：

- 二次构建速度提升 70%+
- 自动缓存 loader、插件结果
- 支持跨进程共享缓存

---

## **8️⃣ 如何利用 `externals` 优化构建？**

> `externals` 用于**排除不希望被打包进 bundle 的依赖**，让其在运行时通过 CDN 或全局变量提供。

```js
// webpack.config.js
externals: {
  react: 'React',
  'react-dom': 'ReactDOM',
}
```

然后在 HTML 中手动引入：

```html
<script src="https://cdn.jsdelivr.net/npm/react@18/umd/react.production.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/react-dom@18/umd/react-dom.production.min.js"></script>
```

✅ 优点：

- 减少 bundle 体积；
- 避免重复打包 React/Vue；
- 提升打包速度。

---

## **9️⃣ 什么是懒加载（Lazy Loading）？**

> 懒加载是一种 **按需加载资源** 的技术，仅在需要时才加载对应模块。

典型场景：

- 路由懒加载；
- 图片懒加载；
- 组件按需加载。

📘 示例（React）：

```js
import React, { lazy, Suspense } from "react";

const Profile = lazy(() => import("./Profile"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Profile />
    </Suspense>
  );
}
```

Webpack 会为 `Profile` 生成独立 chunk。

---

## **🔟 如何减少重复代码和依赖？**

| 方法                    | 说明                                    |
| ----------------------- | --------------------------------------- |
| **SplitChunksPlugin**   | 自动抽离公共模块                        |
| **externals**           | 提取第三方库到 CDN                      |
| **去除重复依赖版本**    | 使用 `npm dedupe` 或 `yarn-deduplicate` |
| **使用 alias 统一依赖** | 避免 `react`、`react-dom` 版本重复      |
| **Scope Hoisting**      | 提升运行效率、减少包裹层                |
| **动态导入**            | 按需加载减少主包体积                    |

```js
optimization: {
  splitChunks: {
    chunks: 'all',
    cacheGroups: {
      vendor: {
        test: /[\\/]node_modules[\\/]/,
        name: 'vendors',
        chunks: 'all',
      },
    },
  },
}
```

---

如果你愿意，我可以帮你把这两套题（上次那 10 题 + 这次这 10 题）整理成一份
📘《Webpack 面试通关手册（附示例代码）》PDF，结构清晰可打印，你要我帮你排版导出吗？
