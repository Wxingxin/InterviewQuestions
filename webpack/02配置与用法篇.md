## 🧩 1. Webpack 的 Entry 配置可以有哪些写法？

**Entry（入口）** 决定了 Webpack 从哪里开始构建依赖图。

Webpack 支持三种写法 👇：

```js
// ① 字符串：单入口
entry: './src/index.js'

// ② 数组：多个文件合并为一个入口（常用于多 polyfill）
entry: ['./src/index.js', './src/polyfill.js']

// ③ 对象：多入口（常用于多页面应用）
entry: {
  home: './src/home.js',
  about: './src/about.js'
}
```

✅ **说明：**

* 当是对象时，每个 key 会生成一个独立的打包文件（如 `home.bundle.js`、`about.bundle.js`）。
* 对应多页应用（MPA）开发常用。

---

## 📦 2. Output 的 filename 和 chunkFilename 区别是什么？

```js
output: {
  filename: '[name].js',           // 主入口文件命名
  chunkFilename: '[name].chunk.js' // 非入口的异步模块命名
}
```

| 字段                | 作用                  | 示例                           |
| ----------------- | ------------------- | ---------------------------- |
| **filename**      | 入口（Entry）对应的打包输出文件名 | `main.js`                    |
| **chunkFilename** | 动态加载（异步 import）的文件名 | `0.chunk.js`、`user.chunk.js` |

📘 **举例：**

```js
import('./user.js') // 动态引入
```

这个异步模块会使用 `chunkFilename` 命名规则输出。

---

## ⚙️ 3. Loader 是如何工作的？

**Loader 的作用：**

> 将非 JavaScript 文件（如 CSS、图片、TypeScript、Vue 文件）转换为 Webpack 能识别的模块。

**工作原理：**

1. Webpack 读取模块；
2. 匹配到 `module.rules` 中的规则；
3. 匹配的文件会按顺序（从右到左）被对应的 loader 处理；
4. 转换后的结果会交给下一个 loader 或 Webpack 自身。

📘 **例子：**

```js
module: {
  rules: [
    {
      test: /\.css$/,
      use: ['style-loader', 'css-loader']
    }
  ]
}
```

* `css-loader` 解析 CSS 为 JS 模块；
* `style-loader` 把样式插入到 `<style>` 标签中。

---

## 🧰 4. 常见的 Loader 有哪些？

| Loader                        | 作用                                |
| ----------------------------- | --------------------------------- |
| **babel-loader**              | 把 ES6+ 转换为兼容浏览器的 ES5              |
| **css-loader**                | 解析 CSS 文件中的 `@import`、`url()`     |
| **style-loader**              | 把 CSS 插入到 `<style>` 标签中           |
| **sass-loader / less-loader** | 把 Sass/Less 编译成 CSS               |
| **url-loader**                | 把小图片转为 base64 内嵌，大图使用 file-loader |
| **file-loader**               | 处理文件资源（图片、字体）输出到指定目录              |
| **ts-loader**                 | 编译 TypeScript                     |
| **vue-loader**                | 解析 `.vue` 单文件组件                   |
| **eslint-loader**             | 检查代码语法规范                          |

---

## 🔌 5. Plugin 与 Loader 的区别？

| 对比项      | Loader                  | Plugin                         |
| -------- | ----------------------- | ------------------------------ |
| **作用**   | 文件转换器                   | 功能扩展器                          |
| **阶段**   | 模块加载阶段                  | 打包整个过程                         |
| **功能**   | 把资源文件转成模块               | 优化、压缩、注入、分析                    |
| **调用方式** | 配置在 `module.rules`      | 配置在 `plugins`                  |
| **例子**   | babel-loader、css-loader | HtmlWebpackPlugin、DefinePlugin |

✅ **一句话区分：**

> Loader 负责“翻译文件”，Plugin 负责“扩展功能”。

---

## 🧱 6. 常见的 Plugin 有哪些？

| Plugin                         | 作用                     |
| ------------------------------ | ---------------------- |
| **HtmlWebpackPlugin**          | 自动生成 HTML 文件并引入打包后的 JS |
| **DefinePlugin**               | 定义全局常量（如环境变量）          |
| **MiniCssExtractPlugin**       | 抽离 CSS 为独立文件           |
| **CleanWebpackPlugin**         | 打包前清空 dist 目录          |
| **HotModuleReplacementPlugin** | 启用 HMR（热更新）            |
| **CopyWebpackPlugin**          | 拷贝静态文件到输出目录            |
| **BundleAnalyzerPlugin**       | 可视化分析打包体积              |

---

## 📁 7. 如何配置 Webpack 的别名 alias？

别名 alias 用于简化路径引用 👇

```js
resolve: {
  alias: {
    '@': path.resolve(__dirname, 'src'),
    '@components': path.resolve(__dirname, 'src/components')
  }
}
```

**使用：**

```js
import Button from '@components/Button';
```

✅ **好处：**

* 避免层层 `../../../`；
* 提高可读性；
* 防止路径错误。

---

## 🧩 8. Webpack 配置多入口多出口该如何实现？

```js
entry: {
  index: './src/index.js',
  admin: './src/admin.js'
},
output: {
  filename: '[name].bundle.js',
  path: path.resolve(__dirname, 'dist')
}
```

Webpack 会分别生成：

```
dist/index.bundle.js
dist/admin.bundle.js
```

📘 多页应用（MPA）可以配合 **HtmlWebpackPlugin** 多实例使用：

```js
plugins: [
  new HtmlWebpackPlugin({ filename: 'index.html', chunks: ['index'] }),
  new HtmlWebpackPlugin({ filename: 'admin.html', chunks: ['admin'] })
]
```

---

## 🧠 9. Webpack 的 Mode 有哪几种？作用是什么？

Webpack 提供三种构建模式：

| 模式              | 特点                         |
| --------------- | -------------------------- |
| **development** | 开发模式，启用调试、未压缩、带 source map |
| **production**  | 生产模式，自动压缩、优化 Tree Shaking  |
| **none**        | 不启用任何默认优化                  |

```js
mode: 'development' // 或 'production'
```

✅ **区别：**

* development 模式下构建快、可调试；
* production 模式下自动压缩优化性能。

---

## ⚙️ 10. Webpack 的配置文件是如何被解析和执行的？

Webpack 会按以下顺序解析配置：

1. 默认读取项目根目录下的 `webpack.config.js`
2. 如果指定了 `--config` 参数，则读取对应文件
3. 加载配置文件（支持 `.js`, `.cjs`, `.mjs`, `.ts`, `.json`）
4. 调用导出的配置对象（或函数）
5. 使用内部的 **Compiler** 实例开始执行打包流程

```js
// webpack.config.js
module.exports = (env, argv) => ({
  entry: './src/index.js',
  mode: argv.mode || 'development'
});
```

Webpack CLI 在启动时会解析命令行参数并传给配置函数。

---

是否要我接着帮你写一份 **Webpack 性能优化面试题大全（含 Tree Shaking、Code Split、HMR 原理）**？
👉 那是面试官最爱问的“加分题”，也是高薪前端的必考内容。
