非常好 👍
这一组题是 Webpack 原理部分的“核心十问”，主要考察模块系统、热更新机制和运行原理。下面我为你逐条解析，每题都配简图思路 + 面试要点总结👇

---

## **1️⃣ Webpack 如何处理 ESModule 和 CommonJS 混用？**

Webpack 内部在解析模块时，不区分 ESM 或 CommonJS。
在构建阶段，Webpack 会通过 AST（抽象语法树）分析两者的导入导出，并将它们都**统一封装成 Webpack 自定义的模块系统**。

### ✅ 处理机制

* 识别导出类型；
* 统一封装为 `__webpack_require__`；
* 自动兼容默认导出与命名导出。

### 📘 例子

```js
// utils.js (CommonJS)
module.exports = { a: 1 }

// index.js (ESM)
import utils from './utils';
console.log(utils.a);
```

Webpack 会自动生成包装代码：

```js
var __webpack_exports__ = __webpack_require__("./utils.js");
```

🧠 **总结**：

> Webpack 通过构建阶段静态分析 + 运行时封装机制，兼容 ESModule 与 CommonJS。

---

## **2️⃣ Webpack 是如何实现模块化加载的？**

Webpack 会将所有模块打包进一个立即执行函数（IIFE）中，并使用 `__webpack_require__` 来模拟 Node.js 的 `require` 功能。

### 💡 模拟机制

1. 所有模块被放进一个对象 `modules = { moduleId: function(...) {...} }`
2. 定义一个缓存对象；
3. 实现自定义的 `__webpack_require__`；
4. 缓存执行结果，防止重复加载。

### 📘 示例

```js
(function(modules) {
  var installedModules = {};

  function __webpack_require__(id) {
    if (installedModules[id]) return installedModules[id].exports;
    var module = installedModules[id] = { exports: {} };
    modules[id].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }

  return __webpack_require__("./src/index.js");
})({
  "./src/index.js": function(module, exports, __webpack_require__) {
    const msg = __webpack_require__("./src/msg.js");
    console.log(msg);
  },
  "./src/msg.js": function(module) {
    module.exports = "Hello Webpack";
  }
});
```

🧠 **总结**：

> Webpack 的模块加载是通过函数包装 + 自定义的 `__webpack_require__` 实现的。

---

## **3️⃣ 什么是 HMR（热更新）？原理是什么？**

**HMR（Hot Module Replacement）** 是 Webpack 的“热模块替换”，可在不刷新页面的情况下实时替换模块内容。

### 🔧 实现流程

1. **Webpack-dev-server 启动本地服务器**
2. 监测源码变化 → Webpack 重新编译
3. 新模块打包存入内存中（非磁盘）
4. DevServer 通过 **WebSocket** 通知浏览器
5. 浏览器执行 `module.hot.accept()` 更新模块

### 📘 代码示例

```js
if (module.hot) {
  module.hot.accept('./math.js', function() {
    console.log('math 模块更新了');
  });
}
```

🧠 **总结**

> HMR 依靠 WebSocket 通信与运行时模块替换机制，实现了模块级的热更新，而无需刷新整个页面。

---

## **4️⃣ Webpack 中 `require.context()` 的作用是什么？**

`require.context()` 是 Webpack 提供的一个函数，用于**批量导入模块**。

### 📘 语法

```js
require.context(directory, useSubdirectories, regExp)
```

### ✅ 示例

```js
const modules = require.context('./components', true, /\.js$/);
modules.keys().forEach(key => {
  console.log(key, modules(key));
});
```

🧠 **作用**

* 动态加载多个文件；
* 常用于 Vue 的自动组件注册；
* Webpack 在编译时就会分析并打包匹配的模块。

---

## **5️⃣ Webpack 中的 `sideEffects` 属性有什么作用？**

`sideEffects` 是帮助 Webpack 做 **Tree Shaking 优化** 的关键配置。

### 📘 配置方式

```json
// package.json
{
  "sideEffects": false
}
```

表示：

* 该包所有文件都**没有副作用**；
* Webpack 可以安全地删除未使用的模块。

### ✅ 例外情况

如果某些文件有副作用：

```json
{
  "sideEffects": ["./src/styles.css"]
}
```

🧠 **总结**

> `"sideEffects": false` 告诉 Webpack 可以安全删除未被引用的模块，提高 Tree Shaking 效果。

---

## **6️⃣ Babel 与 Webpack 的关系是什么？**

> 二者是“编译 + 打包”的关系。

| 工具          | 职责               |
| ----------- | ---------------- |
| **Babel**   | 转译新语法（ES6 → ES5） |
| **Webpack** | 模块打包、依赖管理、资源构建   |

### 📘 配合方式

Webpack 调用 Babel：

```js
module: {
  rules: [
    {
      test: /\.js$/,
      use: 'babel-loader',
      exclude: /node_modules/,
    },
  ],
}
```

🧠 **总结**

> Webpack 调用 Babel 编译文件，Babel 把语法转换成兼容形式，Webpack 再负责输出 bundle。

---

## **7️⃣ 如何在 Webpack 中使用 TypeScript？**

两种方式：

### ✅ 方式 1：`ts-loader`（官方推荐）

```bash
npm install ts-loader typescript -D
```

```js
module: {
  rules: [
    {
      test: /\.tsx?$/,
      use: 'ts-loader',
      exclude: /node_modules/,
    },
  ],
},
resolve: {
  extensions: ['.ts', '.tsx', '.js'],
},
```

### ✅ 方式 2：Babel 转译 TS（更快）

```bash
npm install babel-loader @babel/preset-typescript -D
```

```js
rules: [
  {
    test: /\.tsx?$/,
    use: {
      loader: 'babel-loader',
      options: { presets: ['@babel/preset-typescript'] },
    },
  },
]
```

🧠 **总结**

> `ts-loader` 调用 TypeScript 编译器；`babel-loader` 转译更快但不做类型检查。

---

## **8️⃣ Webpack 中如何配置 polyfill？**

Webpack 5 不再自动注入 Node.js 的 polyfill，需要手动配置。

### ✅ 方法 1：通过 Babel + core-js 自动注入

```bash
npm install core-js regenerator-runtime -D
```

```js
// babel.config.js
{
  presets: [
    ['@babel/preset-env', {
      useBuiltIns: 'usage',
      corejs: 3
    }]
  ]
}
```

### ✅ 方法 2：ProvidePlugin 注入

```js
const webpack = require('webpack');
plugins: [
  new webpack.ProvidePlugin({
    process: 'process/browser',
    Buffer: ['buffer', 'Buffer'],
  }),
];
```

🧠 **总结**

> Babel 用于前端 API polyfill，ProvidePlugin 用于 Node 环境 polyfill。

---

## **9️⃣ Webpack 与 Node.js 的模块系统区别？**

| 对比项  | Webpack                  | Node.js            |
| ---- | ------------------------ | ------------------ |
| 执行环境 | 浏览器                      | 服务端                |
| 加载方式 | 编译时静态加载                  | 运行时动态加载            |
| 模块类型 | ESM + CJS 都可             | 主要是 CJS            |
| 缓存机制 | `__webpack_require__` 缓存 | `require.cache` 缓存 |
| 依赖解析 | enhanced-resolve 算法      | Node 原生算法          |
| 文件输出 | 打包后单文件                   | 每个文件单独加载           |

🧠 **总结**

> Webpack 是**编译时模块系统**，Node 是**运行时模块系统**。

---

## **🔟 Webpack 打包后的代码是如何执行的？**

Webpack 输出的 bundle 是一个自执行函数，内部实现一个简化版的模块系统：

### 📘 执行流程

1. 初始化 `modules` 对象；
2. 定义 `__webpack_require__`；
3. 缓存模块结果；
4. 从入口模块执行；
5. 返回导出内容。

### ✅ 代码结构

```js
(function(modules) {
  var cache = {};

  function __webpack_require__(id) {
    if (cache[id]) return cache[id].exports;
    var module = cache[id] = { exports: {} };
    modules[id].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }

  return __webpack_require__("./src/index.js");
})({
  "./src/index.js": function(module, exports, __webpack_require__) {
    const msg = __webpack_require__("./src/msg.js");
    console.log(msg);
  },
  "./src/msg.js": function(module) {
    module.exports = "Hello Webpack";
  }
});
```

🧠 **总结**

> Webpack 将所有模块包装进函数，通过 `__webpack_require__` 实现加载和依赖管理。

---

是否希望我帮你把这三组（共 30 题）整理成
📘《Webpack 面试 + 原理精讲手册》PDF版？
包含：

* 每题要点总结
* 对比表格
* 图解模块加载与 HMR 机制
  可打印、导入 Notion/语雀学习。

是否要我为你排版导出？
