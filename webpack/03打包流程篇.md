### **1️⃣ Webpack 打包时发生了哪些步骤？**

Webpack 打包大致经历以下流程（从源码到 bundle）：

1. **初始化参数**：读取配置文件（`webpack.config.js`）并合并 CLI 传入参数。
2. **创建 Compiler 实例**：整个构建过程的核心对象。
3. **开始编译**：执行 `compiler.run()`，创建一个新的 **Compilation** 实例。
4. **从 Entry 入口出发**：根据入口（entry）开始解析依赖图。
5. **模块编译**：

   * 使用 Loader 对不同类型文件进行转译（如 `.vue`, `.ts`, `.scss`）。
   * 将模块转换为标准的 JS 模块（CommonJS 格式）。
6. **依赖收集**：在解析模块时递归分析 `import/require` 的依赖，形成依赖图。
7. **Chunk 生成**：将多个模块根据入口或动态加载点打包成不同的 chunk。
8. **输出阶段**：生成最终的 bundle 文件并写入到 `output` 目录。
9. **完成与清理**：触发 `done` 钩子，执行后置插件逻辑。

🧠 **面试思路**：Webpack 核心是“从入口出发 → 递归依赖 → Loader 转换 → Plugin 扩展 → 输出结果”。

---

### **2️⃣ Webpack 的依赖收集是如何实现的？**

Webpack 构建时，会使用 **AST（抽象语法树）** 来分析代码结构：

1. 调用 **Parser（解析器）** 将模块源代码转成 AST。
2. 遍历 AST，识别出：

   * `import ... from ...`
   * `require(...)`
   * 动态 `import()`
3. 把依赖模块路径收集起来，加入依赖图。
4. 递归分析每一个依赖模块，重复这个过程。

最终形成一个**模块依赖图（Module Graph）**，Webpack 就能据此打包出整个项目。

---

### **3️⃣ Loader 的执行顺序是怎样的？**

Loader 是一个 **函数链**，执行顺序为：

> **从右到左（从下到上）执行。**

原因：Webpack 采用“管道流”思想，后一个 loader 的输出会作为前一个的输入。

📦 例如：

```js
use: ['style-loader', 'css-loader', 'postcss-loader']
```

执行顺序：

1. `postcss-loader`
2. `css-loader`
3. `style-loader`

如果 loader 是 **pitching loader**，则还有一个“从左到右”的前置执行阶段。

---

### **4️⃣ Plugin 的执行原理？**

Webpack 的插件系统基于 **Tapable 库**（实现发布-订阅模式）。

📦 机制简述：

* Webpack 在运行时，会在不同阶段触发一系列 **钩子（hooks）**。
* 插件通过注册这些钩子（`compiler.hooks.emit.tapAsync()` 等）来执行逻辑。
* 比如：`HtmlWebpackPlugin` 在 `emit` 阶段修改输出资源。

🔧 示例：

```js
class MyPlugin {
  apply(compiler) {
    compiler.hooks.emit.tap('MyPlugin', (compilation) => {
      console.log('emit 阶段触发');
    });
  }
}
```

---

### **5️⃣ Webpack 的构建生命周期（Compiler、Compilation）**

Webpack 有两个核心对象：

* **Compiler**：整个 Webpack 生命周期的管理者（全局唯一）。
* **Compilation**：一次构建过程的上下文（每次编译都新建一个）。

🔁 **常见生命周期钩子：**

| 阶段            | 作用               |
| ------------- | ---------------- |
| `environment` | 初始化环境            |
| `run`         | 开始一次编译           |
| `compile`     | 创建新的 Compilation |
| `make`        | 从 entry 开始解析依赖   |
| `emit`        | 输出文件到磁盘前         |
| `done`        | 构建完成             |

🧠 面试关键词：“Compiler 管全局、Compilation 管单次编译”。

---

### **6️⃣ Webpack 如何解析模块路径？**

Webpack 使用自定义的模块解析器（基于 enhanced-resolve）：

解析步骤：

1. 检查是否为绝对路径；
2. 若是相对路径（`./`、`../`），从当前文件目录解析；
3. 若为模块名：

   * 查找 `resolve.alias`
   * 查找 `resolve.modules`（默认 `node_modules`）
   * 查找 `resolve.extensions`（如 `.js`, `.ts`, `.jsx`）
   * 遵循 Node.js 模块解析算法。

---

### **7️⃣ 什么是 Chunk？什么是 Bundle？**

| 名称         | 含义                           |
| ---------- | ---------------------------- |
| **Chunk**  | Webpack 在构建时的内部概念，代表一组模块的集合。 |
| **Bundle** | Chunk 最终生成的文件（写入磁盘的产物）。      |

🧩 举例：

* entry → `main` chunk
* 动态 import → `vendors~login` chunk
* 最终输出 → `main.bundle.js`、`vendors~login.bundle.js`

---

### **8️⃣ Hash、ChunkHash、ContentHash 区别？**

| 名称              | 计算范围        | 场景                   |
| --------------- | ----------- | -------------------- |
| **Hash**        | 整个项目的构建结果   | 改动任意文件都会改变           |
| **ChunkHash**   | 当前 Chunk 内容 | 某个入口独立缓存             |
| **ContentHash** | 文件内容本身      | 文件级缓存最精细（常用于 CSS/JS） |

🧠 **面试技巧**：若希望修改一个文件不影响其它缓存 → 使用 `contenthash`。

---

### **9️⃣ Webpack 构建时为什么会很慢？**

主要性能瓶颈：

1. **模块过多 / 文件体积大**；
2. **Loader 处理慢**（如 babel-loader 未开启缓存）；
3. **SourceMap 生成耗时**；
4. **频繁 IO 读写文件**；
5. **插件数量多、逻辑复杂**；
6. **无缓存编译**（未用 `cache-loader`、`hard-source-webpack-plugin`）。

---

### **🔟 如何分析 Webpack 的打包性能瓶颈？**

工具推荐：

1. **webpack-bundle-analyzer**
   👉 可视化依赖包体积。

   ```bash
   npm install webpack-bundle-analyzer -D
   ```

   在配置中：

   ```js
   const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
   plugins: [new BundleAnalyzerPlugin()]
   ```

2. **speed-measure-webpack-plugin (SMP)**
   👉 分析各插件和 loader 的耗时。

   ```js
   const SpeedMeasurePlugin = require('speed-measure-webpack-plugin');
   const smp = new SpeedMeasurePlugin();
   module.exports = smp.wrap(webpackConfig);
   ```

3. **开启 cache / thread-loader**
   👉 启用多线程编译与缓存减少重复处理。

---

是否希望我帮你整理成一份「Webpack 高级面试题答案 PDF」？我可以把这 10 个问题和回答格式化排版，方便打印复习。
