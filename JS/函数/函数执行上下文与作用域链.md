# 一、函数执行上下文（Execution Context）

1.  执行上下文的类型
    - 全局执行上下文：整个脚本首次加载时创建，只有一个
    - 函数执行上下文：每次调用函数时创建，调用多少次就创建多少个
    - Eval 执行上下文：执行 eval 函数内的代码时创建（不推荐使用）
2.  函数执行上下文的创建过程
    - 函数执行上下文的创建分为两个阶段：
    - 阶段 1：创建阶段（进入函数时）
    - - 绑定 this：确定当前函数的 this 指向（根据四大绑定规则）
    - - 创建词法环境（Lexical Environment）：
    - - - 环境记录：存储函数内声明的变量、函数和参数
    - - - 外部环境引用：指向外部执行上下文（形成作用域链）
    - - 创建变量环境（Variable Environment）：与词法环境类似，主要用于存储 var 声明的变量
    - 阶段 2：执行阶段（执行函数体内代码时）
    - - 完成变量赋值
    - - 执行代码逻辑
    - - 处理函数调用
3.  执行上下文栈
    - JavaScript 引擎使用栈（LIFO，后进先出）来管理执行上下文
    - 全局执行上下文先入栈
    - 每次调用函数，新的函数执行上下文入栈
    - 函数执行完毕，其执行上下文出栈
    - 所有代码执行完毕，栈中只剩全局执行上下文

```js
// 示例：执行上下文栈的变化
function foo() {
  console.log("foo 执行");
  bar(); // 调用 bar，bar 执行上下文入栈
}

function bar() {
  console.log("bar 执行");
}

foo(); // 调用 foo，foo 执行上下文入栈

// 执行顺序：全局上下文入栈 → foo 入栈 → bar 入栈 → bar 出栈 → foo 出栈 → 全局上下文出栈
```

```js

```

# 作用域

1. 作用域链的形成
   每个函数执行上下文的词法环境都包含一个「外部环境引用」
   这个引用指向创建当前函数时所在的外部执行上下文（通常是父函数或全局）
   多个这样的引用串联起来，就形成了作用域链
2. 作用域链的作用
   **变量查找机制**：
   - 1.先在当前作用域查找；
   - 2.如果找不到，就去上一层作用域查找；
   - 3.一直查到全局作用域；
   - 4.如果全局也找不到，就报 ReferenceError。
   - 这种逐级查找的关系，叫作用域链。

```js
// 示例：作用域链查找
const globalVar = "全局变量";

function outer() {
  const outerVar = "外层变量";

  function inner() {
    const innerVar = "内层变量";
    // 查找顺序：inner 词法环境 → outer 词法环境 → 全局词法环境
    console.log(innerVar); // 内层变量（当前环境找到）
    console.log(outerVar); // 外层变量（外层环境找到）
    console.log(globalVar); // 全局变量（全局环境找到）
    console.log(notDefined); // undefined（全程未找到）
  }

  inner();
}

outer();
```


