# 闭包最基本的使用

闭包的定义可以从「语法」和「本质」两个层面理解：

**语法定义**：函数嵌套函数时，内层函数引用了外层函数作用域中的变量（或参数），且内层函数被外层函数外部调用，此时就形成了闭包。
**本质核心**：闭包是 JS 「词法作用域」和「函数一等公民」特性共同作用的结果 —— 它让函数突破了作用域的限制，即使外层函数执行完毕（上下文销毁），内层函数依然能访问外层函数的局部变量。

```js
// 外层函数：foo
function foo() {
  // 外层函数的局部变量（本应在 foo 执行完后销毁）
  let message = "Hello, Closure!";

  // 内层函数：bar（嵌套在 foo 中）
  function bar() {
    // 内层函数引用了外层函数的变量 message
    console.log(message);
  }

  // 外层函数返回内层函数（关键：让 bar 能在 foo 外部被调用）
  return bar;
}

// 1. 执行 foo()，得到返回的 bar 函数，赋值给 fn
const fn = foo();
// 2. 在 foo 外部调用 fn（即 bar），依然能访问 foo 中的 message
fn(); // 输出：Hello, Closure!
```



# 面试题

1. 问：闭包是什么？它的形成条件是什么？
   - 答：闭包是内层函数引用外层函数变量，且内层函数在外部被调用时形成的结构，本质是突破作用域限制。
   - 形成条件：① 函数嵌套；② 内层函数引用外层函数的变量 / 参数；③ 内层函数在外部被调用。
2. 问：闭包会导致内存泄漏吗？如何避免？
   - 答：合理使用不会，不合理使用会（如未清理的事件监听、全局变量长期引用）。
   - 避免方案：① 主动移除事件监听 / 定时器；② 用完闭包后释放引用（设为 null）；③ 避免不必要的闭包嵌套。

# 闭包的常见使用场景

👌 明白了，我帮你筛选出 **最常用的 3 个闭包场景**（你在开发里经常会遇到的）：

---

## 🔹JS 闭包常用场景

### 1. **封装私有变量**

常用来保存状态，避免外部随意修改。

```js
function createCounter() {
  let count = 0; // 私有变量
  return function() {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

👉 用于 **计数器、状态管理**。

---

### 2. **异步操作中保存变量**

比如 `setTimeout`，闭包能记住循环时的变量。

```js
for (var i = 1; i <= 3; i++) {
  (function(n) {
    setTimeout(() => console.log(n), 1000);
  })(i);
}
// 输出：1, 2, 3
```

👉 用于 **定时器、事件回调**。

---

### 3. **函数柯里化（传递参数）**

闭包能把参数“记住”，用于生成新函数。

```js
function add(a) {
  return function(b) {
    return a + b;
  };
}

const add5 = add(5);
console.log(add5(10)); // 15
```


✅ 总结：最常见的闭包应用就是

* **封装状态（私有变量）**
* **异步回调保存环境**
* **柯里化函数传参**

