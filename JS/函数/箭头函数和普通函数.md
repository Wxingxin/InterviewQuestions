### 1. **语法形式不同**

- **普通函数**：使用 `function` 关键字声明
- **箭头函数**：使用 `=>` 语法，省略 `function` 关键字，更简洁

```javascript
// 普通函数
function normalFunc(x, y) {
  return x + y;
}

// 箭头函数
const arrowFunc = (x, y) => x + y;

// 单参数可省略括号，单语句返回可省略大括号和return
const double = (num) => num * 2;
```

### 2. **`this` 绑定规则不同（最核心区别）**

- **普通函数**：`this` 指向动态变化，取决于**调用方式**：

  - 全局调用时指向全局对象（浏览器中是 `window`，Node 中是 `global`）
  - 作为对象方法调用时指向该对象
  - 使用 `call`/`apply`/`bind` 可以改变 `this` 指向
  - 构造函数中 `this` 指向新创建的实例

- **箭头函数**：`this` 继承自**外层作用域的 `this`**，且**无法被改变**（没有自己的 `this` 绑定）：

  ```javascript
  const obj = {
    name: "测试",
    normal: function () {
      console.log(this.name); // 指向 obj，输出 "测试"

      // 普通函数：this 指向 window（浏览器环境）
      setTimeout(function () {
        console.log(this.name); // 输出 undefined
      }, 100);

      // 箭头函数：this 继承自外层的 obj
      setTimeout(() => {
        console.log(this.name); // 输出 "测试"
      }, 100);
    },
  };

  obj.normal();
  ```

### 3. **不能作为构造函数**

- **普通函数**：可以使用 `new` 关键字创建实例
- **箭头函数**：不能作为构造函数，使用 `new` 会报错
  ```javascript
  const Arrow = () => {};
  new Arrow(); // 报错：Arrow is not a constructor
  ```

### 4. **没有 `arguments` 对象**

- **普通函数**：内部有 `arguments` 对象，包含所有传入的参数
- **箭头函数**：没有 `arguments` 对象，需使用**剩余参数（`...args`）** 替代

  ```javascript
  // 普通函数
  function normal() {
    console.log(arguments); // 输出所有参数
  }

  // 箭头函数
  const arrow = (...args) => {
    console.log(args); // 用剩余参数接收所有参数
  };
  ```

### 5. **没有 `prototype` 属性**

- **普通函数**：有 `prototype` 属性，可用于实现原型继承
- **箭头函数**：没有 `prototype` 属性

  ```javascript
  function normal() {}
  console.log(normal.prototype); // { constructor: f }

  const arrow = () => {};
  console.log(arrow.prototype); // undefined
  ```

### 6. **不能使用 `yield` 关键字**

- 箭头函数不能作为生成器函数（`function*`），无法使用 `yield`

### 总结：何时使用箭头函数？

- 简化回调函数（如 `setTimeout`、数组方法 `map`/`filter` 等）
- 需要保留外层 `this` 上下文时（避免 `const self = this` 这样的 hack）
- 简短的、无状态的工具函数

不适合使用的场景：

- 对象的方法（会导致 `this` 指向错误）
- 构造函数
- 需要动态 `this` 或 `arguments` 的场景
