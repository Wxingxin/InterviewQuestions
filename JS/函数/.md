# 🔹 基础题

1. **函数声明和函数表达式的区别？**

   - 函数声明会提升（hoisting），可以在声明之前调用。
   - 函数表达式不会提升，只能在定义之后调用。

2. **箭头函数和普通函数的区别？**

   - 箭头函数没有自己的 `this`，它的 `this` 指向定义时的外层作用域。
   - 箭头函数没有 `arguments` 对象。
   - 箭头函数不能作为构造函数（不能用 `new` 调用）。
   - 箭头函数不能使用yield

3. **什么是高阶函数？举个例子。**

   - 高阶函数：接收函数作为参数，或者返回一个函数。
   - 例子：`Array.prototype.map`、`filter`、`reduce`，或者自定义 `debounce`、`throttle`。

4. **立即执行函数（IIFE）有什么作用？**

   - 立即执行，避免变量污染作用域，常用于模块化早期写法。

---

# 🔹 进阶题

5. **函数的参数按值传递还是引用传递？**

   - JavaScript 的参数是 **按值传递**。
   - 对象传递的是“引用的副本”，所以可以修改对象属性，但不能改变对象引用本身。

6. **什么是闭包？**

   - 函数可以“记住”并访问它定义时的词法作用域，即使函数在当前词法作用域之外执行。
   - 常见应用：数据隐藏、工厂函数、函数柯里化。

7. **什么是柯里化（Currying）？**

   - 把一个接受多个参数的函数转换成一系列接受单一参数的函数。
   - 例子：

     ```js
     function curry(fn) {
       return function curried(...args) {
         if (args.length >= fn.length) return fn(...args);
         return (...next) => curried(...args, ...next);
       };
     }
     ```

8. **call、apply、bind 的区别？**

   - `call(thisArg, ...args)` 立即执行，参数逐个传入。
   - `apply(thisArg, [args])` 立即执行，参数以数组传入。
   - `bind(thisArg, ...args)` 不执行，返回一个绑定了 this 的新函数。

9. **实现一个 bind 函数？**

   ```js
   Function.prototype.myBind = function (context, ...args) {
     const fn = this;
     return function (...rest) {
       return fn.apply(context, args.concat(rest));
     };
   };
   ```

---

# 🔹 深入题

10. **函数执行上下文和作用域链是什么？**

    - 执行上下文：函数执行时，会创建作用域、变量对象、`this` 等运行环境。
    - 作用域链：函数查找变量时，会逐层向外查找，直到全局作用域。

11. **事件循环对函数执行的影响？**

    - 回调函数（如 `setTimeout`、Promise `then`）会被放入任务队列，等待主线程空闲时执行。
    - 微任务（Promise、MutationObserver）优先于宏任务（setTimeout、setInterval）。

12. **尾调用优化（Tail Call Optimization，TCO）是什么？JS 支持吗？**

    - 尾调用：函数最后一步调用另一个函数。
    - 理论上可以优化栈空间，防止栈溢出。
    - JS ES6 规范有这个特性，但大多数 JS 引擎（如 V8）并没有完全实现。

13. **如何实现一个 once 函数（只执行一次）？**

    ```js
    function once(fn) {
      let called = false;
      let result;
      return function (...args) {
        if (!called) {
          result = fn.apply(this, args);
          called = true;
        }
        return result;
      };
    }
    ```

14. **new 运算符的底层原理？**

    - 创建一个新对象。
    - 设置原型：新对象的 `__proto__ = 构造函数.prototype`。
    - 执行构造函数，`this` 指向新对象。
    - 如果构造函数返回对象，则返回该对象，否则返回新对象。

---
