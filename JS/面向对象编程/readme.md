# 1

### 1️⃣ JavaScript 中对象是什么？

**答：**

- 对象是 **键值对集合**，可以存储数据（属性）和方法（函数）。
- 在 JS 中，几乎所有非原始类型都是对象，包括数组、函数、日期等。
- 对象是引用类型，存储在堆内存中。

---

### 2️⃣ 对象和数组有什么区别？

| 特性     | 对象                              | 数组                                        |
| -------- | --------------------------------- | ------------------------------------------- |
| 数据结构 | 键值对集合                        | 索引值集合                                  |
| 索引类型 | 字符串 / Symbol                   | 数字（连续或稀疏）                          |
| 内存布局 | 哈希表                            | 连续内存 + 哈希混合                         |
| 方法     | Object.keys / values / entries 等 | push/pop/shift/unshift/map/filter/reduce 等 |
| 用途     | 结构化数据、字典                  | 有序集合、列表                              |

---

### 3️⃣ 如何判断一个变量是否是对象？

**答：**

- `typeof x === "object"`（注意 null 也是 object，需要排除）
- `Object.prototype.toString.call(x) === "[object Object]"`
- `x !== null && typeof x === "object"`

---

### 4️⃣ 对象的属性有哪些类型？

- **数据属性（Data Property）**：存储值，可配置、可写、可枚举
- **访问器属性（Accessor Property）**：通过 getter/setter 访问值

---

### 5️⃣ 对象的 key 可以是哪些类型？

- **字符串**（包括空字符串）
- **Symbol**
- **注意**：数字会被自动转换成字符串，不能直接使用对象或数组作为 key（会被转成 `[object Object]`）

---

### 6️⃣ 对象的 value 可以是哪些类型？

- **原始类型**：number, string, boolean, null, undefined, bigint, symbol
- **引用类型**：对象、数组、函数、Date 等
- JS 对象的值可以是任意类型，包括嵌套对象

---

### 7️⃣ 什么是对象的可枚举性（enumerable）？

- **enumerable** 决定属性是否能被 `for...in` 或 `Object.keys` 遍历
- 默认通过直接赋值创建的属性是可枚举的
- 非枚举属性不会出现在遍历列表中，但仍可访问

---

### 8️⃣ 什么是对象的可配置性（configurable）？

- **configurable** 决定属性是否能被删除或修改其特性（如 writable、enumerable）
- `configurable: false` 时，属性不能被删除，也不能修改特性

---

### 9️⃣ 什么是对象的可写性（writable）？

- **writable** 决定数据属性的值是否可以被修改
- setter 可以控制访问器属性的可写性

---

### 🔟 对象的原型（prototype）是什么？

- **原型**是对象的隐式父对象，属性查找失败时会沿原型链查找
- JS 中每个对象都有一个 `[[Prototype]]` 内部属性（可通过 `__proto__` 或 `Object.getPrototypeOf` 访问）
- 原型机制是 JS 实现继承的核心

# 2

你列出的这 10 个题目属于 **对象常用方法理解类**面试题，我帮你整理标准答案和原理讲解（无代码版）：

---

### 1️⃣ Object.keys、Object.values、Object.entries 的区别？

| 方法                | 返回内容            | 特点                         |
| ------------------- | ------------------- | ---------------------------- |
| Object.keys(obj)    | 属性名数组          | 只返回可枚举属性的 key       |
| Object.values(obj)  | 属性值数组          | 只返回可枚举属性的 value     |
| Object.entries(obj) | `[key, value]` 数组 | 只返回可枚举属性的键值对数组 |

---

### 2️⃣ Object.assign 与展开运算符（...）有什么区别？

- **Object.assign(target, ...sources)**

  - 将源对象的可枚举自有属性复制到目标对象
  - 目标对象被修改

- **展开运算符 `{...obj}`**

  - 创建新对象并浅拷贝源对象的可枚举自有属性
  - 不修改原对象

- **共同点**：都是浅拷贝，不会拷贝继承属性和 Symbol 非枚举属性

---

### 3️⃣ Object.create、Object.setPrototypeOf、Object.getPrototypeOf 的区别？

- **Object.create(proto)**

  - 创建一个新对象，原型指向 `proto`

- **Object.setPrototypeOf(obj, proto)**

  - 动态修改已存在对象的原型

- **Object.getPrototypeOf(obj)**

  - 获取对象的原型

- **注意**：频繁修改原型会影响性能

---

### 4️⃣ Object.freeze、Object.seal、Object.preventExtensions 区别？

| 方法                          | 是否可添加属性 | 是否可删除属性 | 是否可修改属性 | 是否可修改属性特性 |
| ----------------------------- | -------------- | -------------- | -------------- | ------------------ |
| Object.preventExtensions(obj) | ❌             | ✅             | ✅             | ✅                 |
| Object.seal(obj)              | ❌             | ❌             | ✅             | ❌                 |
| Object.freeze(obj)            | ❌             | ❌             | ❌             | ❌                 |

---

### 5️⃣ hasOwnProperty 与 in 操作符的区别？

- **hasOwnProperty(key)**

  - 判断对象自身是否有该属性（不查原型链）

- **in 操作符**

  - 判断对象自身或原型链上是否存在该属性

---

### 6️⃣ Object.is 与 === 的区别？

| 特性     | ===   | Object.is |
| -------- | ----- | --------- |
| NaN 比较 | false | true      |
| +0 与 -0 | true  | false     |
| 其他值   | 相同  | 相同      |

---

### 7️⃣ delete 删除对象属性的行为？

- `delete obj.key` 删除对象自有属性
- 返回 true/false 表示是否删除成功
- 不会影响原型链上的属性
- 数据属性 `configurable: false` 无法删除

---

### 8️⃣ 对象浅拷贝与深拷贝的区别？

- **浅拷贝**

  - 只复制对象第一层属性
  - 嵌套对象仍然引用原对象

- **深拷贝**

  - 复制对象所有层级
  - 修改嵌套对象不会影响原对象

- 方法：JSON.parse(JSON.stringify(obj)、递归拷贝、第三方库（lodash.cloneDeep）

---

### 9️⃣ for...in 与 for...of 遍历对象的区别？

- **for...in**

  - 遍历对象**可枚举属性**（包括继承属性）
  - 不适合数组

- **for...of**

  - 只能遍历**可迭代对象**（数组、Map、Set、字符串）
  - 不能直接遍历普通对象

---

### 🔟 JSON.stringify 对象有哪些限制？

- 忽略函数、Symbol 属性
- 忽略不可枚举属性
- 循环引用会报错
- 只序列化自身可枚举属性
- 日期会被转换成字符串
- undefined 会被转成 null（数组中）

---

# 3

非常好 👍
你这一组问题属于 **“对象性能与内存优化类”面试题**，是高级前端或 Node.js 面试里非常常考的一类。下面是详细答案解析（无代码版、逻辑清晰版）：

---

### 1️⃣ 对象访问性能和数组访问性能差异

- **数组访问（基于索引）**：连续内存布局，访问复杂度约为 O(1)，CPU 缓存友好。
- **对象访问（基于哈希表）**：内部通过哈希查找属性，虽然理论也是 O(1)，但有哈希计算与冲突处理开销。
- **总体结论**：

  - 小规模访问差别不大
  - 大量数据场景下，**数组访问更快、更稳定**

---

### 2️⃣ 对象大数据量时如何优化性能

- 避免频繁增删属性（会触发隐藏类（hidden class）变化，影响 JIT 优化）
- 固定属性结构（结构稳定能让 V8 优化对象）
- 使用 `Map` 或 `WeakMap` 存储大规模键值对
- 避免过深嵌套（访问链过长影响性能）
- 分片处理：大对象拆成多个逻辑子对象

---

### 3️⃣ 原型链查找性能和直接对象属性访问性能差异

- 直接属性访问：一次哈希查找即可，O(1)
- 原型链访问：沿原型链逐层查找，最坏 O(n)
- 原型链越深 → 查找越慢
- 优化建议：

  - 尽量将频繁访问的属性定义在对象自身
  - 不滥用多层继承

---

### 4️⃣ 对象属性频繁增删改对性能有影响吗？

✅ 有

- V8 引擎会为每个对象生成隐藏类（Hidden Class）用于优化访问路径
- 若频繁增删属性，隐藏类不断变化，JIT 优化失效 → 降级为慢属性访问
- **建议**：

  - 初始化时定义好所有属性
  - 不要在运行时频繁增删结构

---

### 5️⃣ 对象的动态属性与静态属性性能差异

- **静态属性**：对象创建时结构固定，JIT 优化路径稳定 → 访问更快
- **动态属性**：运行时添加，破坏优化路径 → 访问更慢
- **结论**：

  - 尽量避免随意添加属性
  - 使用类（class）或固定结构对象更高效

---

### 6️⃣ 如何避免对象导致内存泄漏

- 清理无用引用（如全局对象、闭包未释放）
- 避免循环引用（对象相互持有）
- 不滥用缓存对象（老数据不清除）
- 使用 `WeakMap` / `WeakSet` 存放弱引用数据
- 避免长期存储 DOM 引用或外部资源

---

### 7️⃣ 使用 Map 与普通对象存储大量 key/value 的性能差异

| 项目          | Object         | Map              |
| ------------- | -------------- | ---------------- |
| 键类型        | 字符串、Symbol | 任意类型         |
| 插入/删除性能 | 一般           | 更优             |
| 键值对数量    | 不可直接获取   | 可用 `size`      |
| 迭代顺序      | 不保证顺序     | 按插入顺序       |
| 内存占用      | 较小           | 稍高             |
| 性能趋势      | 小规模适用     | 大数据量明显更快 |

**结论**：大数据量存储 → **推荐用 Map**

---

### 8️⃣ 对象合并（assign/扩展运算符）大对象性能优化方法

- 避免深层嵌套对象频繁拷贝
- 使用浅合并（浅层对象不递归）
- 对超大对象合并时可分批处理或使用流式结构
- 避免在热路径（频繁执行的函数中）使用 `Object.assign`

---

### 9️⃣ 如何用对象缓存计算结果（Memoization）

- 利用对象键值存储输入与输出映射
- 每次计算前检查缓存 → 若存在直接返回
- 可配合 `WeakMap` 避免对象键引用泄漏
- 常用于递归或高计算成本函数

---

### 🔟 如何避免对象访问冲突或覆盖

- 命名空间划分（如 `user.name` 与 `user.meta.name`）
- 使用唯一键（Symbol）防止属性名冲突
- 使用模块封装私有数据
- 或者使用 Proxy 拦截属性读写，检测冲突行为

# 4

非常棒，这组是「**对象底层行为与陷阱类**」高频面试题 ✅
以下是每一题的完整解析与面试答题要点（无代码版）👇

---

### 1️⃣ 对象属性名为数字或特殊字符会有什么影响？

- 在对象中，**属性名最终都会被转为字符串**（除 Symbol 外）。
  例如：`obj[1]` 实际等价于 `obj["1"]`。
- **特殊字符**（如空格、短横线、中文）可以存在，但：

  - 若直接用点号访问会报错（必须用方括号访问）；
  - JSON 序列化时会自动转为字符串键。

- **排序规则**：数字键会按升序排列在字符串键之前（例如：`{"2":…, "10":…, "a":…}`）。

---

### 2️⃣ 原型链覆盖属性会产生什么问题？

- 如果子对象定义了与原型相同的属性名，会**遮蔽（shadow）**原型链上的同名属性。
- 后续访问该属性时，只能访问到实例自己的属性，**无法访问原型上的同名属性**。
- 常见问题：

  - 原型方法被误覆盖；
  - 不同对象间共享逻辑被破坏；
  - 继承层级复杂时，属性来源难以追踪。

**优化建议**：使用 `Object.hasOwn()` 或 `Object.prototype.hasOwnProperty()` 检查属性归属。

---

### 3️⃣ 对象引用与浅拷贝修改原对象的影响？

- 对象是**引用类型**，赋值只是拷贝引用（指针），两者指向同一块内存。
- 浅拷贝仅复制第一层属性，**嵌套对象依然共享引用**。
- 结果：修改副本的嵌套属性 → 原对象也被修改。
- 要彻底隔离 → 需使用深拷贝（例如结构化克隆、手写递归或 `structuredClone()`）。

---

### 4️⃣ 使用 `for...in` 遍历对象可能产生的问题？

- 会遍历**原型链上的可枚举属性**，非自身属性也会被访问。
- 遍历顺序**非固定**（数字键优先、再字符串、再 Symbol）。
- 性能不如 `Object.keys()` / `Object.entries()`。
- 若对象来自外部或继承复杂 → 容易出现“污染遍历结果”的问题。

---

### 5️⃣ 对象属性可枚举性和 `for...in` 遍历的关系？

- `for...in` 只遍历**可枚举（enumerable 为 true）**的属性。
- 使用 `Object.defineProperty()` 定义属性时，可设置 `enumerable: false`。
- `Object.keys()` 也仅返回可枚举属性。
- `Object.getOwnPropertyNames()` 可获取所有属性（包括不可枚举的）。

---

### 6️⃣ 使用 `delete` 后对象的内存是否立即释放？

- **不会立即释放。**
- `delete` 只是移除对象上的属性引用；
  具体的内存释放由 **垃圾回收器（GC）** 决定。
- 影响：

  - 可能导致对象结构变化 → 触发 V8 隐藏类重新生成 → 降低性能；
  - 不推荐在性能敏感代码中频繁使用。

---

### 7️⃣ `Object.freeze()` 后对象属性能否被修改？

- `Object.freeze()` 使对象**不可扩展、不可配置、不可写**：

  - 无法添加/删除属性；
  - 无法修改现有属性值；
  - 无法改变属性描述符；
  - 但嵌套对象仍可修改（非深冻结）。

- 若要彻底冻结对象（递归冻结），需手动实现 `deepFreeze()`。

---

### 8️⃣ 对象包含函数时，浅拷贝是否安全？

- 通常是**安全的**（因为函数本身是不可变的引用）。
- 但注意：

  - 如果函数内部使用了闭包变量，拷贝后的函数仍引用原闭包；
  - 若函数内部引用外部对象，可能出现“隐式共享”。

- 结论：浅拷贝不会复制函数逻辑或闭包，只复制函数引用。

---

### 9️⃣ `Symbol` 类型作为 key 的特点？

- 不会被 `for...in`、`Object.keys()`、`JSON.stringify()` 枚举；
- 只能通过 `Object.getOwnPropertySymbols()` 或 `Reflect.ownKeys()` 获取；
- 保证键的**唯一性**，避免命名冲突；
- 常用于定义对象“私有属性”或框架内部标识（例如：`Symbol.iterator`）。

---

### 🔟 对象序列化和反序列化的限制（`JSON.stringify`）

- **无法序列化的内容**：

  - `undefined`、`symbol`、`function` 属性；
  - 循环引用对象（会报错）；
  - 原型链属性不会被包含；
  - `Map`、`Set`、`Date`、`RegExp` 等特殊对象会被简化为普通对象或空对象。

- **反序列化限制**：

  - `JSON.parse()` 会丢失类型信息；
  - 日期会变为字符串；
  - 不支持方法或原型链恢复。

# 5

非常棒 👏
这组问题是「**对象应用与实践场景类面试题**」，在 React / Vue / Node.js 面试中都非常常见。
下面是逐题深度解析（无代码版 + 面试答题要点）👇

---

### 1️⃣ 如何实现对象深拷贝？

**核心思路：** 拷贝对象的所有层级内容，彻底断开引用关系。
**常见实现方式：**

- ✅ `structuredClone()`（现代浏览器内置，性能优）；
- ❌ `JSON.parse(JSON.stringify(obj)`（会丢函数、Symbol、原型）；
- 🔁 递归手写（可保留类型和嵌套）；
- 💡 第三方库：`lodash.cloneDeep()`、`rfdc()`。
  **考点：**
- 能否正确处理循环引用；
- 能否保留特殊对象类型（如 Date、Map、Set）。

---

### 2️⃣ 如何实现对象属性监听（Proxy / defineProperty）？

**两种方案：**

1. `Object.defineProperty()`

   - 只能监听已有属性；
   - 无法检测新增、删除；
   - Vue2 使用该机制实现响应式。

2. `Proxy`（ES6）

   - 可拦截读写、删除、in 操作；
   - 能代理整个对象（含嵌套属性）；
   - Vue3 基于 Proxy 实现响应式系统。
     **结论：**
     现代开发优先使用 **Proxy** 实现可扩展的响应式监听。

---

### 3️⃣ 如何用对象实现哈希表功能？

- 对象天然是键值对结构，可直接作为哈希表；
- Key 会被强制转为字符串；
- 若键类型复杂（如对象），应使用 `Map`；
- 对象适合存储轻量、固定格式数据；
- 若需 O(1) 查询、插入，可通过 `obj[key]` 实现。
  **加分点：** 解释 Map 与对象的底层差异（哈希 vs 隐藏类结构）。

---

### 4️⃣ 如何实现对象的合并去重？

- **浅合并**：`Object.assign()` 或展开运算符 `{ ...a, ...b }`；
- **深合并**：递归合并嵌套结构；
- **去重逻辑**：合并同名属性时根据优先级保留；
- 对象数组合并可通过 `key` 去重（常用于接口数据整合）。
  **注意性能：** 大对象合并时建议分步或懒加载处理。

---

### 5️⃣ 如何实现对象的防抖 / 节流缓存？

- **核心思想**：利用对象缓存函数调用状态。

  - 防抖：使用对象保存计时器 ID；
  - 节流：保存上次执行时间；
  - 缓存：以参数序列化为 key 存储结果（Memoization）。
    **典型应用：**

- 高频请求优化；
- 计算型函数缓存；
- 组件渲染防抖。

---

### 6️⃣ 如何判断两个对象是否相等？

- `===` 只比较引用；
- 浅比较：逐层比较基本类型属性；
- 深比较：递归比较对象的每个键值；
- JSON 比较仅限结构简单对象；
- 面试重点：**考虑嵌套、类型、数组、函数、循环引用。**
  **扩展：** React 的 `shallowEqual`、`_.isEqual` 都是常见实现。

---

### 7️⃣ 如何将对象转成数组，或数组转回对象？

- `Object.entries(obj)` → 获取键值对数组；
- `Object.keys()` / `Object.values()` → 提取数组形式；
- 数组转对象：

  - 通过 `reduce()` 累加；
  - 或使用 `Object.fromEntries()`。
    **应用：**

- 数据表格结构转换；
- JSON 配置转键值映射。

---

### 8️⃣ 如何实现对象多层嵌套访问安全（可选链 / get 方法）？

- 可选链（`?.`）防止访问未定义属性时报错；
- 旧方案：自定义 `get(obj, path)`；
- Vue、Lodash、React Query 都有类似实现；
- **意义**：提高健壮性，避免 `Cannot read property of undefined` 异常。

---

### 9️⃣ 对象在前端状态管理中的典型应用（Redux、Vuex）？

- Redux / Vuex 的 state 本质都是一个普通对象；
- 对象作为单一状态源（Single Source of Truth）；
- 使用对象可以方便：

  - 状态快照（immutable 更新）；
  - 局部更新；
  - diff 比较；
  - 序列化与持久化。
    **延伸考点：** Redux 中通过浅拷贝 + 对象展开符实现不可变更新。

---

### 🔟 如何用对象模拟类和私有属性？

- 使用对象封装数据与行为（函数属性）；
- 私有属性可用闭包或 `Symbol` 模拟；
- ES2022 已正式支持 `#private` 属性；
- **面试延伸点**：

  - 对象模拟类 → 构造函数模式；
  - 对象 + 闭包 → 模拟封装；
  - `WeakMap` 实现真正私有数据存储。

---
