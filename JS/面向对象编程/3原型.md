# 1
JavaScript当中每个对象都有一个特殊的内置属性 [Iprototypll,这个特殊的对象可奥影一对象
1. 那么这个对象有什么用呢？
2. 当我们通过引l用对象的属性key来获取一个value时，它会触发[[Get]]的操作;口这个操作会首先检查该对象是否有对应的属性，如果有的话就使用它；
3. 如果对象中没有改属性，那么会访问对象```[[prototype]]```内置属性指向的对象上的属性；
4. 那么如果通过字面量直接创建一个对象，这个对象也会有这样的属性吗？如果有，应该如何获取这个属性呢？口答案是有的，只要是对象都会有这样的一个内置属性；
5. 获取的方式有两种：
- 方式一：通过对象的_proto_属性可以获取到（但是这个是早期浏览器自己添加的，存在一定的兼容性问题）;
- 口方式二：通过Object.getPrototypeOf 方法可以获取到


# 2 函数的原型prototype

所有的函数都有一个prototype的属性（注意：不是_proto_）

1. 你可能会问题，老师是不是因为函数是一个对象，所以它有prototype的属性呢？口不是的，因
- 为它是一个函数，才有了这个特殊的属性;
- 而不是它是一个对象，所以有这个特殊的属性;

# 3 new
 new操作 new Person（）
1. 常见空对象
var obj = {}

2.将这个空对象赋值给this
`this = obj`

3.将函数的显式原型赋值给这个对象作为它的隐式原型
`obj._proto_ = Person.prototype`
3.执行函数体中代码

4.将这个对象默认返回

# 4
### 1
```js

function Student(name,age,son){
  this.name = name
  this.age = age
  this.sno = son

  this.running = function(){
    console.log(this.name+"running")
  }
  this.eating = function(){
    console.log(this.name+"eating")
  }
  this.studying = function(){
    console.log(this.name+"studying")
  }
}

const stu1 = new Student("why",12,111)
const stu2 = new Student("wei",22,666)

console.log(stu1.running === stu2.running)//false
```
stu1 stu2 2个对象都会创建代码中的3个方法占用更多的内存

### 2

11·当我们多个对象拥有共同的值时，·我们可以将它放到构造函数对象的显式原型
11-由构造函数创建出来的所有对象，都会共享这些属性
```js
function Student(name,age,son){
  this.name = name
  this.age = age
  this.sno = son

}
  Student.prototype.running = function(){
    console.log(this.name+"running")
  }
  Student.prototype.eating = function(){
    console.log(this.name+"eating")
  }
  Student.prototype.studying = function(){
    console.log(this.name+"studying")
  }

const stu1 = new Student("why",12,111)
const stu2 = new Student("wei",22,666)
//·隐式原型的作用
//·1>·stu1的隐式原型是谁?·Student.prototype对象
// 2>·stu1.running查找：
//先在自己身上查找，·没有找到
//去原型去查找
console.log(stu1.running === stu2.running)//true
```