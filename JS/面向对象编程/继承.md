# 大全

| 继承方式       | 优点                   | 缺点                 |
| -------------- | ---------------------- | -------------------- |
| 原型链继承     | 继承父类方法           | 引用属性共享         |
| 借用构造函数   | 继承实例属性，避免共享 | 无法继承方法         |
| 组合继承       | 属性+方法都能继承      | 父类构造函数调用两次 |
| 原型式继承     | 简单                   | 属性引用共享         |
| 寄生式继承     | 增强对象               | 效率低               |
| 寄生组合继承   | 完美方案（ES5）        | 写法稍复杂           |
| ES6 Class 继承 | 简洁，语法糖           | 底层仍是原型链       |

# 原型链继承

⚠️ 缺点：多个实例共享引用属性。

```js
function Parent() {
  this.colors = ["red", "blue"];
}
function Child() {}
Child.prototype = new Parent();

const c1 = new Child();
c1.colors.push("green");
console.log(c1.colors); // ["red", "blue", "green"]

const c2 = new Child();
console.log(c2.colors); // ["red", "blue", "green"] ❌ 共享引用
```

# 借用构造函数

⚠️ 缺点：不能继承 Parent.prototype 上的方法。

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}
function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
const c1 = new Child("Alice", 20);
console.log(c1.colors); // 独立副本
```

# 组合继承

✅ 优点：继承属性 + 方法。
⚠️ 缺点：Parent 构造函数调用了两次（浪费内存）

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}
Parent.prototype.sayHi = function () {
  console.log(`Hi, I'm ${this.name}`);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
Child.prototype = new Parent(); // 继承方法
Child.prototype.constructor = Child;

const c1 = new Child("Alice", 20);
c1.sayHi(); // Hi, I'm Alice
```

# 原型式继承

👉 Object.create(proto) 创建一个对象，原型指向 proto。

```js
const parent = {
  name: "Alice",
  sayHi() {
    console.log(`Hi, I'm ${this.name}`);
  },
};
const child = Object.create(parent);
child.name = "Bob";
child.sayHi(); // Hi, I'm Bob
```

# 寄生式继承

在原型式继承的基础上增强对象。

```js
function createChild(obj) {
  const clone = Object.create(obj);
  clone.sayHi = function () {
    console.log("Hello!");
  };
  return clone;
}
const child = createChild({ name: "Alice" });
child.sayHi(); // Hello!
```

# 寄生组合继承

✅ 优点：避免父类构造函数被调用两次。

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "blue"];
}
Parent.prototype.sayHi = function () {
  console.log(`Hi, I'm ${this.name}`);
};

function Child(name, age) {
  Parent.call(this, name); // 继承属性
  this.age = age;
}
// 只继承原型，不调用 Parent 构造函数
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;

const c1 = new Child("Alice", 20);
c1.sayHi(); // Hi, I'm Alice
```

# ES6 Class 继承

👉 class 和 extends 本质还是基于原型的语法糖。

```js
class Parent {
  constructor(name) {
    this.name = name;
    this.colors = ["red", "blue"];
  }
  sayHi() {
    console.log(`Hi, I'm ${this.name}`);
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name); // 相当于 Parent.call(this, name)
    this.age = age;
  }
}

const c1 = new Child("Alice", 20);
c1.sayHi(); // Hi, I'm Alice
```
