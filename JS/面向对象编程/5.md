# 💯💯💯 1
### 情况1
```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

function Student(name, age, sno, score) {
  this.name = name;
  this.age = age;
  this.sno = sno;
  this.score = score;
}

Student.prototype.running = function () {
  console.log("running");
};
Student.prototype.eating = function () {
  console.log("eating");
};
Student.prototype.studying = function () {
  console.log("studying");
};
```
### 情况 2
```js
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

function Student(name, age, height, address, sno, score) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
  this.sno = sno;
  this.score = score;
}
Student.prototype.running = function () {
  console.log("running");
};
Student.prototype.eating = function () {
  console.log("eating");
};
Student.prototype.studying = function () {
  console.log("studying");
};
```

# 1️⃣ 💯💯💯 原型链继承

原型链继承的弊端
但是目前有一个很大的弊端：某些属性其实是保存在 p 对象上的：海量资源：666java.com 口第一，我们通过直接打印对象是看不到这个属性的;
第二，这个属性会被多个对象共享，如果这个对象是一个引用类型，那么就会造成问题；
第三，不能给 Person 传递参数（让每个 stu 有自己的属性），因为这个对象是一次性创建的（没办法定制化）；

### 方式一：·父类的原型直接赋值给子类的原型

缺点：父类和子类共享通一个原型对象，·修改了任意一个，·另外一个也被修改

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

function Student(name, age, sno, score) {
  this.name = name;
  this.age = age;
  this.sno = sno;
  this.score = score;
}

Student.prototype.studying = function () {
  console.log("studying");
};

var stu1 = new Student("gao", 23, 111, 100);
stu1.running(); //error
```

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

function Student(name, age, sno, score) {
  this.name = name;
  this.age = age;
  this.sno = sno;
  this.score = score;
}

//原型继承
Student.prototype = Person.prototype;

Student.prototype.studying = function () {
  console.log("studying");
};

var stu1 = new Student("gao", 23, 111, 100);
stu1.running(); //running
```

### 3 创建一个父类的实例对象（new Person()） 用这个实例对象来作为子类的原型对象

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

function Student(name, age, sno, score) {
  this.name = name;
  this.age = age;
  this.sno = sno;
  this.score = score;
}

//change
var p = new Person("why", 18);
Student.prototype = p;

Student.prototype.studying = function () {
  console.log("studying");
};

var stu1 = new Student("gao", 23, 111, 100);
stu1.running(); //running
```

### 继承 Person 的属性

继承 Person 自身没有的属性，创建

# 2️⃣ 💯💯💯 借用构造函数（构造函数继承）

```js
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

function Student(name, age, height, address, sno, score) {
  Person.call(this, name, age, height, address);

  this.sno = sno;
  this.score = score;
}

//change
var p = new Person("why", 18);
Student.prototype = p;

Student.prototype.studying = function () {
  console.log("studying");
};

var stu1 = new Student("gao", 23, 111, 100);
stu1.running(); //running
```

# 3️⃣ 💯💯💯 组合继承

组合继承是 JavaScript 最常用的继承模式之一：

- 如果你理解到这里，点到为止，那么组合来实现继承只能说问题不大；
- 但是它依然不是很完美，但是基本已经没有问题了

## ✅ 一、目标：

让 `Student` 继承 `Person` 的 **实例属性 + 原型方法**。
同时不能用 `Object.create()`。

---

## 🧩 二、实现代码（标准组合继承写法，不用 Object.create）

```js
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

// ---------------------------
// ✅ 组合继承，不用 Object.create()
// ---------------------------
function Student(name, age, height, address, sno, score) {
  // 1️⃣ 构造函数继承 —— 继承实例属性
  Person.call(this, name, age, height, address);

  this.sno = sno;
  this.score = score;
}

// 2️⃣ 原型链继承 —— 继承原型方法
Student.prototype = new Person(); // ✅ 不用 Object.create()

// 3️⃣ 修复 constructor
Student.prototype.constructor = Student;

// 4️⃣ 添加自己的方法
Student.prototype.studying = function () {
  console.log("studying");
};

// ---------------------------
// ✅ 测试
// ---------------------------
const stu1 = new Student("Gao", 23, 180, "Shanghai", 111, 100);
console.log(stu1.name); // Gao
stu1.running(); // running ✅ 来自 Person.prototype
stu1.studying(); // studying ✅ 来自 Student.prototype
```

---

## 🧠 三、原理解析（为什么是组合继承）

| 部分             | 用途         | 实现                                      |
| ---------------- | ------------ | ----------------------------------------- |
| 构造函数继承     | 继承实例属性 | `Person.call(this, ...)`                  |
| 原型链继承       | 继承原型方法 | `Student.prototype = new Person()`        |
| 修复 constructor | 修复指向     | `Student.prototype.constructor = Student` |

这样 `Student` 的实例可以：

- 拥有 `Person` 的实例属性（`name`, `age`, `height`, `address`）
- 也能调用 `Person.prototype` 上的方法（`running`, `eating`）

---

## 📊 四、继承结构图

```
stu1 ---> Student.prototype ---> Person.prototype ---> Object.prototype
   ↑
 (实例)
```

当执行：

```js
stu1.running();
```

查找顺序：
1️⃣ `stu1` 自身没有 →
2️⃣ 找到 `Student.prototype` →
3️⃣ 它是 `new Person()` 出来的对象 →
4️⃣ 它的原型是 `Person.prototype` → 找到 `running()` ✅

---

## ⚠️ 五、这种写法的缺点

虽然完全符合“组合继承”，但有一个小问题：

> `Person` 的构造函数被执行了 **两次**

一次在：

```js
Student.prototype = new Person(); // 建立原型链时
```

一次在：

```js
Person.call(this, name, age, height, address); // 在 Student 构造函数中
```

这会导致：

- 父类实例属性（`name`, `age` 等）被初始化两次
- `Student.prototype` 上也存在一份冗余属性（不影响功能，但浪费内存）

---

## ✅ 六、总结

| 特性                 | 是否实现                                     | 说明 |
| -------------------- | -------------------------------------------- | ---- |
| 继承父类实例属性     | ✅ `Person.call(this, …)`                    |      |
| 继承父类原型方法     | ✅ `Student.prototype = new Person()`        |      |
| 修复 constructor     | ✅ `Student.prototype.constructor = Student` |      |
| 使用 Object.create() | ❌ 否                                        |      |
| 缺点                 | ⚠️ 父构造函数执行两次（冗余）                |      |

---

✅ **一句话总结：**

> 这就是经典的「组合继承」写法 ——
> `Person.call(this, …)` + `Student.prototype = new Person()`
> 不用 `Object.create()` 也能完美继承父类的属性与方法。

# 4️⃣ 💯💯💯 原型式继承

明白了，你想把你这段 **`Person` / `Student`** 的代码改成 **原型式继承（Prototypal Inheritance）** 的形式。
原型式继承的核心思想是：**直接用一个对象作为新对象的原型**，不依赖构造函数调用父类。

---

## 🧩 一、改写你的代码为原型式继承

```js
// 1️⃣ 父对象（可以理解为父类实例或模板对象）
const person = {
  name: "why",
  age: 18,
  height: 180,
  address: "Shanghai",
  running() {
    console.log("running");
  },
  eating() {
    console.log("eating");
  }
};

// 2️⃣ 原型式继承创建子对象
function createObject(o) {
  function F() {}
  F.prototype = o;
  return new F();
}

// 3️⃣ 创建子对象 student，继承 person
const student = createObject(person);

// 4️⃣ 添加子对象独有属性和方法
student.sno = 111;
student.score = 100;
student.studying = function () {
  console.log("studying");
};

// ---------------------------
// 测试
// ---------------------------
console.log(student.name); // why（继承自 person）
student.running();  // running（继承自 person）
student.studying(); // studying（子对象自己定义的）
```

---

## 🧩 二、使用 ES5+ 的简化写法

```js
const student = Object.create(person);

student.sno = 111;
student.score = 100;
student.studying = function() {
  console.log("studying");
};

student.running();  // running
```

---

## 🧠 三、原型式继承特点

1. **不使用构造函数**
   直接把已有对象作为原型。

2. **子对象可以访问父对象的属性和方法**
   通过原型链访问。

3. **子对象可以增加自己的属性和方法**
   不会影响父对象。

4. **适合对象克隆和轻量继承**
   比较灵活，但不能传参给“父对象构造函数”。

---

## 📊 四、内存结构示意

```
student ---> person ---> Object.prototype
```

* `student.running()` → 查找 student → 没有 → 查找 person → 找到
* `student.studying()` → student 自己定义 → 找到

---

✅ **总结**：

原型式继承核心是：

> **子对象通过原型链访问父对象的属性和方法，父对象可以作为模板，不需要构造函数。**

# 5️⃣ 💯💯💯 寄生式继承

明白了，你希望**在你原有的 `Person` 和 `Student` 构造函数的基础上**，实现 **寄生式继承**，而不要引入 `Object.create` 或额外模板对象。
我帮你改写成符合你原有代码风格的寄生式继承实现。

---

## 🧩 寄生式继承改写

```js
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

// ---------------------------
// Student 寄生式继承 Person
// ---------------------------
function Student(name, age, height, address, sno, score) {
  // 1️⃣ 创建一个继承自 Person 的对象
  const student = new Person(name, age, height, address);

  // 2️⃣ 给新对象添加 Student 特有属性
  student.sno = sno;
  student.score = score;

  // 3️⃣ 给新对象添加 Student 特有方法
  student.studying = function () {
    console.log("studying");
  };

  // 4️⃣ 返回这个对象
  return student;
}

// ---------------------------
// 测试
// ---------------------------
const stu1 = Student("Gao", 23, 180, "Shanghai", 111, 100);

console.log(stu1.name);    // Gao
stu1.running();             // running（继承自 Person）
stu1.studying();            // studying（Student 自己的方法）
```

---

## 🧠 特点分析

1. **核心思想**：

   > 在构造函数内部创建一个父类实例，然后增强该对象，最后返回它。

2. **原型链结构**：

```
stu1 ---> Person.prototype ---> Object.prototype
```

* `stu1.running()` → Person.prototype 上查找
* `stu1.studying()` → stu1 自己定义

3. **与组合继承的区别**：

   * 组合继承：`Student.prototype = new Person()` → Student 的所有实例共享方法
   * 寄生继承：每次调用 `Student()` 都会创建一个新的对象 → 方法不会共享

4. **优缺点**：

   * ✅ 可以增强对象
   * ❌ 方法不共享，内存上每个实例都重新创建方法




# 6️⃣ 💯💯💯 寄生组合继承

明白了，你希望使用**最原始、手写的方式**实现 **寄生组合继承**，**不要封装成 `inheritPrototype` 函数**，直接在你的 `Person` / `Student` 代码上改写。

下面是完整示例：

---

## 🧩 寄生组合继承（手写版，不封装）

```js
// 父类构造函数
function Person(name, age, height, address) {
  this.name = name;
  this.age = age;
  this.height = height;
  this.address = address;
}

Person.prototype.running = function () {
  console.log("running");
};
Person.prototype.eating = function () {
  console.log("eating");
};

// ---------------------------
// 子类构造函数
function Student(name, age, height, address, sno, score) {
  // 构造函数继承（继承实例属性）
  Person.call(this, name, age, height, address);

  this.sno = sno;
  this.score = score;
}

// ---------------------------
// 寄生组合继承（手写原型链继承，不调用父构造函数）
// ---------------------------

// 1️⃣ 创建父类原型的副本对象
Student.prototype = Object.create(Person.prototype);

// 2️⃣ 修复 constructor 指向
Student.prototype.constructor = Student;

// 3️⃣ 添加子类方法
Student.prototype.studying = function () {
  console.log("studying");
};

// ---------------------------
// 测试
// ---------------------------
const stu1 = new Student("Gao", 23, 180, "Shanghai", 111, 100);

console.log(stu1.name);    // Gao
stu1.running();             // running（继承自 Person.prototype）
stu1.eating();              // eating（继承自 Person.prototype）
stu1.studying();            // studying（Student 自己方法）
```

---

## 🧠 原理说明

1. `Person.call(this, …)`

   * 在子类构造函数里执行父类构造函数
   * 继承父类实例属性

2. `Student.prototype = Object.create(Person.prototype)`

   * 创建一个父类原型的副本对象，不调用父类构造函数
   * 实现对父类方法的继承

3. `Student.prototype.constructor = Student`

   * 修复 constructor 指向，否则指向 Person

4. `Student.prototype.studying = …`

   * 添加子类特有方法

---

## 📊 原型链结构示意

```
stu1 ---> Student.prototype ---> Person.prototype ---> Object.prototype
```

* 实例属性在 `stu1` 自身
* 父类方法共享在 `Person.prototype`
* 子类方法在 `Student.prototype`

---

✅ **总结**：

> 手写寄生组合继承的关键就是：
>
> 1. 构造函数继承实例属性
> 2. 用 `Object.create` 创建父类原型副本继承方法
> 3. 修复 constructor
> 4. 添加子类方法
