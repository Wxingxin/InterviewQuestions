# 📘 3. 查找方法

这些方法用来 **找元素/判断存在性**：

### 1) `indexOf(value, fromIndex = 0)`

-  返回**第一次出现的索引**，找不到返回 `-1`。
-  **严格相等（===）比较**。

```js
[1, 2, 3, 2].indexOf(2); // 1
[1, 2, 3].indexOf(5); // -1
```

### 2) `lastIndexOf(value, fromIndex = arr.length - 1)`

-  从右向左查找，返回最后一次出现的索引。

```js
[1, 2, 3, 2].lastIndexOf(2); // 3
```

### 3) `includes(value, fromIndex = 0)`

-  判断数组里是否包含某值，返回布尔值。
-  和 `indexOf` 的区别：

   -  `includes(NaN)` ✅ 正常工作。
   -  `indexOf(NaN)` ❌ 永远找不到。

```js
[NaN].includes(NaN); // true
[NaN].indexOf(NaN); // -1
```

### 4) `find(fn)`

-  找到**第一个符合条件的元素**，否则返回 `undefined`。

```js
[1, 2, 3, 4].find((x) => x > 2); // 3
```

### 5) `findIndex(fn)`

-  找到**第一个符合条件的索引**，否则返回 `-1`。

```js
[1, 2, 3, 4].findIndex((x) => x > 2); // 2
```

---

# 📘 4. 遍历工具

这些方法会依次执行回调函数，适合做条件判断。

### 1) `every(fn)`

-  检查是否**全部元素符合条件**。
-  短路：遇到 `false` 就停。

```js
[2, 4, 6].every((x) => x % 2 === 0); // true
```

### 2) `some(fn)`

-  检查是否**至少有一个符合条件**。
-  短路：遇到 `true` 就停。

```js
[1, 3, 5].some((x) => x % 2 === 0); // false
[1, 3, 4].some((x) => x % 2 === 0); // true
```

### 3) `forEach(fn)`

-  遍历执行回调，**没有返回值**。
-  ⚠️ 不能中途退出（只能用 `throw` 或 `return` 跳出当前回调）。

```js
[1, 2, 3].forEach((x) => console.log(x * 2));
// 输出 2, 4, 6
```

---

# 🔑 总结表

| 方法                      | 返回值           | 能否中断 | 常见用途               |
| ------------------------- | ---------------- | -------- | ---------------------- |
| `indexOf` / `lastIndexOf` | 索引 / -1        | ❌       | 查找元素位置           |
| `includes`                | 布尔值           | ❌       | 是否包含某值           |
| `find`                    | 元素 / undefined | ✅       | 找第一个符合条件的值   |
| `findIndex`               | 索引 / -1        | ✅       | 找第一个符合条件的索引 |
| `every`                   | 布尔值           | ✅       | 全部符合               |
| `some`                    | 布尔值           | ✅       | 至少一个符合           |
| `forEach`                 | undefined        | ❌       | 遍历执行副作用         |

---

要不要我帮你整理一份 **数组学习全家桶思维导图**（增删改查 + 遍历 + 高阶函数 + ES 新方法）？这样你能一图掌握所有方法。
