当然知道 👍
数组的 **链式调用 (chaining)** 本质上就是利用 **返回数组的新方法**，让结果继续调用下一个方法，写成一条“流水线”。

---

# 📘 数组链式调用

## 一、为什么能链式调用？

- JS 数组的大部分方法（`map`、`filter`、`slice`、`concat`、`flatMap` 等）会返回一个 **新的数组**。
- 这样就可以在返回的数组上继续调用方法。
- 类似 `Promise` 的链式写法。

---

## 二、例子：数据处理流水线

```js
const nums = [1, 2, 3, 4, 5, 6];

// 需求：找出偶数 → 平方 → 只保留大于 10 的数
const result = nums
  .filter((n) => n % 2 === 0) // [2, 4, 6]
  .map((n) => n * n) // [4, 16, 36]
  .filter((n) => n > 10); // [16, 36]

console.log(result); // [16, 36]
```

---

## 三、常见链式调用组合

### 1) `filter + map`

数据筛选 + 转换：

```js
const names = ["alice", "bob", "anna", "mike"];

const res = names
  .filter((name) => name.startsWith("a"))
  .map((name) => name.toUpperCase());

console.log(res); // ["ALICE", "ANNA"]
```

### 2) `map + reduce`

转换后做累计：

```js
const nums = [1, 2, 3];

const sumSquares = nums
  .map((n) => n * n) // [1, 4, 9]
  .reduce((a, b) => a + b, 0);

console.log(sumSquares); // 14
```

### 3) `flatMap`

一次性完成 `map` + `flat`：

```js
const arr = ["hi", "ok"];

const chars = arr.flatMap((str) => str.split(""));

console.log(chars); // ["h", "i", "o", "k"]
```

---

## 四、链式调用注意点

1. **性能问题**

   - 每次都会创建新数组，如果链很长，在大数据量下可能影响性能。
   - 可用 `for` 循环优化，但可读性会差。

2. **可读性 vs 性能**

   - 一般推荐写链式调用，代码更直观、函数式风格。
   - 如果在性能瓶颈处（比如 10w+ 数据），再考虑手动优化。

3. **不能链式的情况**

   - 像 `forEach`、`some`、`every` 返回的不是数组（而是布尔值或 undefined），不能继续链下去。

---

✅ 总结：

- **能链式调用的数组方法**：`map`、`filter`、`slice`、`concat`、`flat`、`flatMap`、`sort`、`reverse` 等。
- **不能链式的数组方法**：`forEach`、`reduce`、`some`、`every`、`includes`、`indexOf`（因为返回非数组）。

---

要不要我帮你写一份 **数组方法链式调用速查表**（哪些能链，哪些不能链）？
