当然可以 👍 我来带你从**原理 → 示例 → 实现**讲清楚「延迟执行函数」的手写方式。

---

## 💡 一、题目说明

所谓「延迟执行函数」指的是：

> 调用函数后，函数不会立刻执行，而是延迟一段时间再执行（例如防抖 debounce 或延迟执行 delay）。

---

## ✅ 二、基础实现：简单延迟执行

```js
function delay(fn, wait) {
  return function (...args) {
    setTimeout(() => {
      fn.apply(this, args);
    }, wait);
  };
}
```

### 🔍 示例

```js
function sayHi(name) {
  console.log("Hello,", name);
}

const delayedSayHi = delay(sayHi, 2000);

delayedSayHi("Jiaxing"); // 2秒后输出：Hello, Jiaxing
```

**原理：**

* `delay` 返回一个新函数；
* 调用时使用 `setTimeout` 延迟执行；
* 通过 `apply` 保留 `this` 和参数。

---

## ⚙️ 三、进阶版：支持取消执行

```js
function delay(fn, wait) {
  let timer = null;
  const delayed = function (...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
      timer = null;
    }, wait);
  };
  delayed.cancel = function () {
    clearTimeout(timer);
    timer = null;
  };
  return delayed;
}
```

### 🔍 示例

```js
const delayedLog = delay(() => console.log("执行了！"), 3000);

delayedLog(); // 调用后3秒执行
delayedLog.cancel(); // 如果在3秒内调用了 cancel()，不会执行
```

---

## 🚀 四、延伸面试问法

面试官可能继续追问你：

| 问题                    | 思路                                           |
| --------------------- | -------------------------------------------- |
| 1️⃣ 防抖和延迟执行的区别？       | 防抖（debounce）会重置计时器，只有停止触发后才执行；延迟执行只是固定等待后执行。 |
| 2️⃣ 延迟执行中如何保持 this？   | 使用 `apply(this, args)` 或箭头函数绑定外层 `this`。     |
| 3️⃣ 如果希望立即执行一次，后续延迟呢？ | 可以增加一个 `immediate` 参数（同防抖函数）。                |

---

是否希望我帮你写一个「延迟 + 防抖 + 节流」三合一版本？（面试常考综合题）
