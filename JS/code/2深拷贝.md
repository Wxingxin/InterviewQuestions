```js
function deepclone(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj; // 原始值直接返回
  }

  if (obj instanceof Date) {
    return new Date(obj); // 处理 Date
  }

  if (obj instanceof RegExp) {
    return new RegExp(obj); // 处理正则
  }

  // 判断是数组还是对象
  let deepobj = Array.isArray(obj) ? [] : {};

  for (let key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      deepobj[key] = deepclone(obj[key]);
    }
  }

  return deepobj; // 别忘了返回
}
```

# 讲解循环引用

- 如果不处理会造成 栈溢出。

```js
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== "object") return obj;

  // 如果 hash 中已经存在该对象（说明之前遇到过，可能是循环引用或多次引用同一对象），直接返回之前创建的拷贝，避免无限递归或重复拷贝。
  // 这是处理循环引用（如 a.self = a）的关键。
  if (hash.has(obj)) return hash.get(obj);

  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);

  const result = Array.isArray(obj) ? [] : {};
  // 把原对象和新创建的空容器记录到 hash 中。顺序很重要：必须先 set，再递归拷贝子属性，这样当遇到循环引用时能返回正确的引用。
  hash.set(obj, result);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key], hash);
    }
  }

  return result;
}
```
