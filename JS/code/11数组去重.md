好问题 👍，数组去重在 JS 里有很多不同写法，不同场景可以选择不同方式。下面我给你总结常见的 **8 种方法**：

---

## 1. **使用 `Set`**

最常见、最简单的方法。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = [...new Set(arr)];
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 2. **使用 `filter + indexOf`**

保留数组中第一次出现的元素。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = arr.filter((item, index) => arr.indexOf(item) === index);
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 3. **使用 `reduce + includes`**

通过累加器构造新数组。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = arr.reduce((acc, cur) => {
  if (!acc.includes(cur)) acc.push(cur);
  return acc;
}, []);
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 4. **使用 `for + includes`**

最基础的循环写法。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = [];
for (let i = 0; i < arr.length; i++) {
  if (!unique.includes(arr[i])) {
    unique.push(arr[i]);
  }
}
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 5. **使用 `Map`**

通过哈希表记录是否出现过。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const map = new Map();
const unique = [];
for (let item of arr) {
  if (!map.has(item)) {
    map.set(item, true);
    unique.push(item);
  }
}
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 6. **使用 `Object`**

利用对象的键不重复。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const obj = {};
const unique = [];
for (let item of arr) {
  if (!obj[item]) {
    obj[item] = true;
    unique.push(item);
  }
}
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 7. **使用 `sort` + `for`**

先排序，再去重。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
arr.sort((a, b) => a - b);
const unique = [arr[0]];
for (let i = 1; i < arr.length; i++) {
  if (arr[i] !== arr[i - 1]) {
    unique.push(arr[i]);
  }
}
console.log(unique); // [1, 2, 3, 4, 5]
```

---

## 8. **ES6 `Array.from(new Set())`**

另一种 `Set` 写法。

```js
const arr = [1, 2, 2, 3, 4, 4, 5];
const unique = Array.from(new Set(arr));
console.log(unique); // [1, 2, 3, 4, 5]
```

---

✅ **总结对比**：

- **推荐**：`Set`（简单、快）
- **兼容性更好**：`filter + indexOf`
- **控制更灵活**：`Map` / `Object`

---

要不要我帮你写一份 **数组去重的性能对比测试**（几万条数据，跑不同方法看速度）？
