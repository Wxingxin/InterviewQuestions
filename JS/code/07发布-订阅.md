你说的 **订阅**，其实就是 **发布-订阅模式 (Pub/Sub)**，核心就是：

- 有一个事件中心（管理事件和对应的回调函数）。
- 这个 EventEmitter 实现了 发布订阅模式（Pub-Sub） 的核心功能：
- subscribe：订阅事件（支持取消订阅函数返回）。
- publish：发布事件（调用所有监听器）。
- unsubscribe：取消某个事件的某个回调。
- once：只执行一次的订阅。

```js
class EventEmitter {
  constructor() {
    // 存储事件和回调
    // 用来存储 事件名称 和 对应的回调函数数组
    this.events = {};
  }

  // 订阅
  // 功能：监听某个事件，把回调函数保存到 events[event] 数组中。
  // 如果事件不存在，就初始化为空数组。
  // 返回值：一个函数，调用它会自动执行 unsubscribe，相当于 取消订阅。
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  // 发布
  //   功能：触发某个事件，执行所有监听这个事件的回调。
  // ...args：支持传递任意参数给回调函数。
  emit(event, ...args) {
    if (this.events[event]) {
      this.events[event].forEach((callback) => {
        callback(...args);
      });
    }
  }

  // 取消订阅
  // 功能：从事件对应的回调数组中删除某个函数。
  // 用 filter 保留不等于 callback 的函数。
  off(event, callback) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter((cb) => cb !== callback);
    }
  }

  // 只订阅一次
  // 功能：事件只触发一次。
  // 原理：用一个 wrapper 包裹原始回调。
  // 第一次执行时，先调用 callback。
  // 然后立即 unsubscribe，确保后面不会再触发。
  once(event, callback) {
    const wrapper = (...args) => {
      callback(...args);
      this.unsubscribe(event, wrapper); // 调用一次后移除
    };
    this.subscribe(event, wrapper);
  }
}

// ============ 使用示例 ============
const emitter = new EventEmitter();

const sub1 = emitter.subscribe("news", (msg) => {
  console.log("订阅者1 收到消息:", msg);
});

const sub2 = emitter.subscribe("news", (msg) => {
  console.log("订阅者2 收到消息:", msg);
});

// 发布事件
emitter.publish("news", "今天下雨 ☔");

// 取消订阅 sub1
sub1();

// 再次发布
emitter.publish("news", "明天放晴 ☀️");

// 只监听一次
emitter.once("onlyOnce", (msg) => {
  console.log("只触发一次:", msg);
});

emitter.publish("onlyOnce", "第一次 ✅");
emitter.publish("onlyOnce", "第二次 ❌");
```

### 输出结果：

```
订阅者1 收到消息: 今天下雨 ☔
订阅者2 收到消息: 今天下雨 ☔
订阅者2 收到消息: 明天放晴 ☀️
只触发一次: 第一次 ✅
```

