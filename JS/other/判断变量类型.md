
## 🎯 一、JS 判断变量类型的方法总览

| 方法                                            | 适用范围                | 特点          |
| --------------------------------------------- | ------------------- | ----------- |
| `typeof`                                      | 基本类型判断              | 简单快捷，但有缺陷   |
| `instanceof`                                  | 引用类型判断（对象）          | 基于原型链       |
| `Object.prototype.toString.call()`            | 精准判断所有类型            | 推荐通用方法      |
| `Array.isArray()`                             | 判断数组                | 更语义化        |
| `constructor`                                 | 判断对象的构造函数           | 可能被篡改，不安全   |
| `isNaN()` / `Number.isNaN()`                  | 判断是否是 NaN           | 用于数值检测      |
| `Number.isFinite()`                           | 判断是否为有限数值           | 检测 Infinity |
| `== null`                                     | 判断 null 或 undefined | 简写技巧        |
| `typeof value === 'object' && value !== null` | 判断是否为对象             | 排除 null     |

---

## 🧩 二、`typeof` —— 判断基本类型的首选工具

### ✅ 用法：

```js
typeof 123           // 'number'
typeof 'hello'       // 'string'
typeof true          // 'boolean'
typeof undefined     // 'undefined'
typeof Symbol()      // 'symbol'
typeof 123n          // 'bigint'
typeof function(){}  // 'function'
```

### ⚠️ 缺点：

```js
typeof null      // ❌ 'object'（历史遗留问题）
typeof []        // ❌ 'object'
typeof {}        // 'object'
```

所以 `typeof` 无法准确区分 **对象、数组、null**。

---

## 🧱 三、`instanceof` —— 判断引用类型（基于原型链）

### ✅ 用法：

```js
[] instanceof Array           // true
{} instanceof Object          // true
new Date() instanceof Date    // true
/abc/ instanceof RegExp       // true
```

### ⚙️ 原理：

`instanceof` 判断的是：

> **某对象的原型链上是否有指定构造函数的 `prototype`。**

### ⚠️ 注意：

```js
let arr = [];
arr instanceof Object  // true（因为 Array.prototype.__proto__ === Object.prototype）

let iframeArr = window.frames[0].Array;
let a = [];
a instanceof iframeArr // false，跨 iframe 会失效
```

👉 适合**同窗口环境**的引用类型判断，不适合跨环境。

---

## 🧬 四、`Object.prototype.toString.call()` —— 最精准通用方法 💎

### ✅ 用法：

```js
Object.prototype.toString.call(123)            // [object Number]
Object.prototype.toString.call('hi')           // [object String]
Object.prototype.toString.call([])             // [object Array]
Object.prototype.toString.call({})             // [object Object]
Object.prototype.toString.call(null)           // [object Null]
Object.prototype.toString.call(undefined)      // [object Undefined]
Object.prototype.toString.call(new Date())     // [object Date]
Object.prototype.toString.call(/abc/)          // [object RegExp]
Object.prototype.toString.call(Symbol())       // [object Symbol]
```

### ✅ 封装成函数：

```js
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
}

// 示例：
getType([])        // 'array'
getType(null)      // 'null'
getType(123)       // 'number'
getType(new Date())// 'date'
```

👉 推荐：这是**最通用、最可靠的类型判断方法**。

---

## 🌈 五、`Array.isArray()` —— 判断数组的专用方法

### ✅ 用法：

```js
Array.isArray([])          // true
Array.isArray({})          // false
Array.isArray('string')    // false
```

### ⚙️ 优点：

比 `instanceof Array` 更安全（可跨 iframe 判断）。

---

## 🧠 六、`constructor` —— 判断构造函数来源

### ✅ 用法：

```js
(123).constructor === Number      // true
('hi').constructor === String     // true
([]).constructor === Array        // true
({}).constructor === Object       // true
```

### ⚠️ 缺陷：

构造函数可以被篡改：

```js
function Foo(){}
Foo.prototype.constructor = Array;
const f = new Foo();
f.constructor === Array; // true ❌
```

👉 不推荐在安全性要求高的代码中使用。

---

## 💡 七、特殊判断：NaN、Infinity、null、undefined

| 目标               | 方法                    | 示例                                                    |
| ---------------- | --------------------- | ----------------------------------------------------- |
| NaN              | `Number.isNaN()`      | `Number.isNaN(NaN)` ✅                                 |
| 有限数              | `Number.isFinite()`   | `Number.isFinite(10)` ✅；`Number.isFinite(Infinity)` ❌ |
| null             | `value === null`      | 直接判断                                                  |
| undefined        | `value === undefined` | 或 `typeof value === 'undefined'`                      |
| null 或 undefined | `value == null`       | 双等号简写技巧                                               |

---

## 🧮 八、综合封装：万能类型判断函数

```js
function typeOf(value) {
  const type = Object.prototype.toString.call(value).slice(8, -1).toLowerCase();
  if (type === 'number' && isNaN(value)) return 'nan';
  return type;
}

// 示例
typeOf([])          // 'array'
typeOf({})          // 'object'
typeOf(null)        // 'null'
typeOf(NaN)         // 'nan'
typeOf(123)         // 'number'
typeOf(() => {})    // 'function'
typeOf(new Map())   // 'map'
```

---

## 🧭 九、常见类型判断对比表

| 值            | typeof    | instanceof | toString           | 备注  |
| ------------ | --------- | ---------- | ------------------ | --- |
| `123`        | number    | ❌          | [object Number]    | ✅   |
| `'hi'`       | string    | ❌          | [object String]    | ✅   |
| `true`       | boolean   | ❌          | [object Boolean]   | ✅   |
| `undefined`  | undefined | ❌          | [object Undefined] | ✅   |
| `null`       | object ❌  | ❌          | [object Null]      | ✅   |
| `[]`         | object    | ✅ Array    | [object Array]     | ✅   |
| `{}`         | object    | ✅ Object   | [object Object]    | ✅   |
| `/abc/`      | object    | ✅ RegExp   | [object RegExp]    | ✅   |
| `new Date()` | object    | ✅ Date     | [object Date]      | ✅   |
| `NaN`        | number    | ❌          | [object Number]    | 特殊值 |
| `() => {}`   | function  | ✅ Function | [object Function]  | ✅   |

---

是否希望我帮你做一个**「JS 类型判断方法对比图」**（思维导图或表格图形式）？
这样你可以一眼看到每种方法的优缺点和适用场景。
