### 一、变量声明方式

#### 1. **var（ES5 及以前）**

- **函数作用域**：在函数内部声明的变量对整个函数可见。
- **可重复声明**：同一作用域内可多次声明同一变量。
- **变量提升**：声明会被提升到作用域顶部，但赋值不会。

```javascript
function example() {
  if (true) {
    var x = 10;
  }
  console.log(x); // 10（函数作用域）
}

console.log(y); // undefined（变量提升，但未赋值）
var y = 20;
```

#### 2. **let 和 const（ES6+）**

- **块级作用域**：在 `{}` 内声明的变量仅在该块内可见。
- **不可重复声明**：同一作用域内重复声明会报错。
- **暂时性死区（TDZ）**：变量在声明前无法访问。

```javascript
function example() {
  if (true) {
    let x = 10;
    const y = 20;
  }
  console.log(x); // 报错：x is not defined
  console.log(y); // 报错：y is not defined
}

console.log(z); // 报错：Cannot access 'z' before initialization
let z = 30;
```

### 二、作用域类型

#### 1. **全局作用域**

- 全局变量在整个程序中可见。
- 在浏览器中，全局作用域的变量附加到 `window` 对象。

```javascript
var globalVar = "I'm global";
console.log(window.globalVar); // "I'm global"
```

#### 2. **函数作用域**

- `var` 声明的变量具有函数作用域。

```javascript
function demo() {
  var funcVar = "Inside function";
  if (true) {
    var sameScope = "Same scope";
  }
  console.log(sameScope); // "Same scope"
}
```

#### 3. **块级作用域**

- `let` 和 `const` 声明的变量具有块级作用域。

```javascript
{
  let blockVar = "Inside block";
  const constant = 42;
}
console.log(blockVar); // 报错：blockVar is not defined
```

### 三、变量提升（Hoisting）

- **var**：声明被提升到作用域顶部，赋值留在原地。
- **let/const**：声明被提升，但存在暂时性死区（TDZ），无法在声明前访问。

```javascript
console.log(a); // undefined（var 提升）
var a = 10;

console.log(b); // 报错：Cannot access 'b' before initialization
let b = 20;
```

### 四、闭包（Closures）

闭包是指有权访问另一个函数作用域中的变量的函数，即使该函数已执行完毕。

#### 1. **基本示例**

```javascript
function outer() {
  let count = 0;
  function inner() {
    count++; // 闭包捕获并记住 count
    return count;
  }
  return inner;
}

const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2
```

#### 2. **闭包的应用**

- **数据封装**：实现私有变量和方法。
- **函数柯里化**：延迟执行和参数复用。
- **事件处理**：保存事件发生时的状态。

```javascript
// 私有计数器
function createCounter() {
  let count = 0;
  return {
    increment: () => count++,
    getCount: () => count,
  };
}

const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // 1
```

### 五、词法作用域（Lexical Scoping）

- 作用域由代码书写时的位置决定，而非调用时的位置。

```javascript
function outer() {
  let x = 10;
  function inner() {
    console.log(x); // 10（词法作用域：inner 定义时捕获 x）
  }
  return inner;
}

const closure = outer();
closure(); // 即使 outer 已执行完毕，仍能访问 x
```

### 六、常见问题与注意事项

#### 1. **循环中的闭包陷阱**

```javascript
// 错误示例：所有定时器都输出 5
for (var i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 1000); // 输出 5, 5, 5, 5, 5
}

// 正确示例：使用 let 创建块级作用域
for (let i = 0; i < 5; i++) {
  setTimeout(() => console.log(i), 1000); // 输出 0, 1, 2, 3, 4
}
```

#### 2. **全局变量污染**

- 避免在全局作用域声明过多变量，可能导致命名冲突。

```javascript
// 不良实践
var appState = { ... }; // 全局变量

// 更好的做法：使用模块或立即执行函数
const app = (() => {
  let state = { ... }; // 私有状态
  return {
    getState: () => state
  };
})();
```

#### 3. **const 的不可变性**

- `const` 保证变量引用不变，但对象/数组内容可修改。

```javascript
const obj = { a: 1 };
obj.a = 2; // 合法：修改对象内容
obj = { b: 2 }; // 报错：无法重新赋值
```

### 七、作用域链（Scope Chain）

- 当访问一个变量时，JavaScript 会先在当前作用域查找，若找不到则沿作用域链向上查找，直到全局作用域。

```javascript
let globalVar = "Global";

function outer() {
  let outerVar = "Outer";
  function inner() {
    let innerVar = "Inner";
    console.log(innerVar); // "Inner"
    console.log(outerVar); // "Outer"（沿作用域链查找）
    console.log(globalVar); // "Global"
  }
}
```
