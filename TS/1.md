TypeScript 的类型系统层级（Type Hierarchy）非常像一个倒金字塔或树状结构。理解这个层级的关键在于理解 **“集合论”**（Set Theory）和 **“可赋值性”**（Assignability）：

  * **父类型（Supertype）** 是包含更多值的集合。
  * **子类型（Subtype）** 是包含更少、更具体值的集合。
  * 子类型总是可以赋值给父类型（Upcasting）。

以下是 TypeScript 类型系统的完整层级图谱：

-----

### 1\. 顶层类型 (Top Types)

位于层级最顶端，包含所有可能的值。

  * **`unknown`**:
      * 这是**类型安全的**顶层类型。
      * **包含：** 任何值（对象、原始值、null、undefined 等）。
      * **规则：** 任何类型都可以赋值给 `unknown`，但 `unknown` 不能直接赋值给除了 `any` 和 `unknown` 之外的任何类型（除非先进行类型收窄/断言）。
  * **`any`**:
      * 这是**类型不安全的**顶层类型（同时也像是一个逃生舱）。
      * **规则：** 它是所有类型的父类型，也是所有类型的子类型（为了兼容性）。使用它会关闭 TypeScript 的类型检查。

> **核心区别**：`unknown` 是 "我知道它是某样东西，但我还不知道具体是什么（所以我不能乱用）"；`any` 是 "我不在乎它是什么，别烦我"。

-----

### 2\. 上层对象类型 (Object Types)

在顶层之下，是非原始值的广义集合。

  * **`Object` (大写 O)**: 包含所有拥有 `toString`、`hasOwnProperty` 等方法的类型。这几乎包含了除了 `null` 和 `undefined` 之外的所有值（包括原始值，因为它们有包装对象）。
  * **`{}` (空对象字面量)**: 行为几乎等同于 `Object`。
  * **`object` (小写 o)**: 代表所有**非原始类型**（non-primitive）。即不能是 number, string, boolean, symbol, null, undefined。通常用于表示引用类型。

-----

### 3\. 基础类型与字面量 (Primitives & Literals)

这是我们在日常开发中最常接触的中间层。

#### 3.1 原始类型 (Primitive Types)

包含 `number`, `string`, `boolean`, `bigint`, `symbol`。

#### 3.2 字面量类型 (Literal Types)

这是原始类型的**子类型**。

  * `"Hello"` 是 `string` 的子类型。
  * `42` 是 `number` 的子类型。
  * `true` 是 `boolean` 的子类型。

**示例：**

```typescript
let specific: "Hello" = "Hello";
let general: string = specific; // ✅ 合法：子类型赋值给父类型
// let fail: "Hello" = general; // ❌ 错误：父类型不能赋值给子类型
```

-----

### 4\. 特殊类型 (void, null, undefined)

  * **`void`**: 通常作为函数的返回值，表示函数不返回任何有意义的值。它大概位于 `undefined` 的上方。
  * **`null` 和 `undefined`**:
      * **在 `strictNullChecks: true` (默认/推荐) 模式下**：它们是独立的类型，互不兼容，且不是 `object` 的子类型。
      * **在 `strictNullChecks: false` 模式下**：它们是所有类型的子类型（除了 `never`）。这意味着你可以把 `null` 赋值给 `number`。

-----

### 5\. 底层类型 (Bottom Type)

位于层级最底端，是空集。

  * **`never`**:
      * **定义：** 不包含任何值的集合。
      * **规则：** `never` 是**所有**类型的子类型。
      * **用途：**
        1.  表示根本不会有返回值的函数（例如：抛出异常、无限循环）。
        2.  在联合类型（Union Types）中被自动剔除（因为它表示不可能发生的情况）。
        3.  用于“全面性检查”（Exhaustiveness Checking）。

-----

### 总结：层级可视化

为了方便记忆，我们可以将其整理为以下的赋值流向图（箭头表示 **"可以赋值给"**，即子类型 -\> 父类型）：

```mermaid
graph BT
    %% Bottom Type
    Never[never] --> LitStr["字面量 (e.g., 'abc')"]
    Never --> LitNum["字面量 (e.g., 123)"]
    Never --> LitBool["字面量 (true/false)"]
    Never --> Null[null]
    Never --> Undefined[undefined]

    %% Literals to Primitives
    LitStr --> String[string]
    LitNum --> Number[number]
    LitBool --> Boolean[boolean]

    %% Primitives to Top/Obj (Simplified)
    String --> Unknown[unknown]
    Number --> Unknown
    Boolean --> Unknown
    Null --> Unknown
    Undefined --> Unknown
    
    %% Object Types
    Array[Array] --> Object[object (小写)]
    Function[Function] --> Object
    Object --> BigObject[Object (大写) / {}]
    BigObject --> Unknown

    %% Top Types
    Unknown --> Any[any]
    Any --> Unknown
    
    %% Note: strictNullChecks 开启时的逻辑
```

### 关键层级表

| 层级 | 类型示例 | 描述 |
| :--- | :--- | :--- |
| **Top** | `unknown`, `any` | 包含所有值。 |
| **Super** | `Object`, `object`, `{}` | 包含对象和（部分）原始值包装。 |
| **Base** | `string`, `number`, `boolean` | 具体的原始类型。 |
| **Sub** | `'text'`, `100`, `true` | 字面量类型（具体的值）。 |
| **Bottom**| `never` | 空集，没有任何值。 |

-----

### 你可以做的下一步

为了加深理解，你可以给我一段你最近写的涉及复杂类型的代码（比如使用了 `infer`, `extends`, 或泛型约束的代码），我可以帮你分析其中的**类型收窄（Narrowing）或父子类型关系**是如何工作的。