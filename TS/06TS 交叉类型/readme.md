TypeScript 的 **交叉类型（Intersection Types）`&`** 和 **interface 声明合并** 是两个完全不同的机制，  
面试里 90% 的人会把它们混为一谈，大厂二面以上必考区别！

下面用一张最清晰的对比表 + 终极记忆口诀，直接背会就能在面试中碾压 95% 候选人。

| 项目                   | 交叉类型 `A & B`           | interface 同名声明合并            |
| ---------------------- | -------------------------- | --------------------------------- |
| 语法                   | `type C = A & B`           | 直接写两个 `interface Box {}`     |
| 触发时机               | 显式写 `&` 时              | 两个同名 interface 自动合并       |
| **同名基础类型属性**   | **直接报错**（TS 2345）    | **直接报错**（TS 2339 / TS 2414） |
| **同名非基础类型属性** | **取后者（从右往左覆盖）** | **合并为一个属性，类型必须兼容**  |
| 最终结果               | 生成一个新类型             | 把多个声明合并成同一个 interface  |
| 是否支持函数重载       | 不支持                     | 支持（自动变成 overload）         |

### 关键区别：同名属性合并规则完全相反！

| 属性类型                              | 交叉类型 `&`（type）                | interface 声明合并             |
| ------------------------------------- | ----------------------------------- | ------------------------------ |
| **基础类型**（string/number/boolean） | 报错！<br>`string & number → never` | 报错！<br>同名基础类型直接冲突 |
| **对象类型**（包括 interface）        | 从右往左覆盖（后者覆盖前者）        | 必须类型兼容，否则报错         |
| **函数**                              | 从右往左覆盖（最后一个生效）        | 自动变成函数重载（顺序敏感）   |
| **可选 vs 必选**                      | 必选覆盖可选（最终是必选）          | 可选覆盖必选（最终是可选）     |

### 经典代码对比（面试必出）

```ts
// 1. 交叉类型 &（type）
interface A {
  name: string;
}
interface B {
  name: number;
}
type C = A & B; // 报错！name 类型冲突 → never

interface X {
  age: number;
}
interface Y {
  age?: string;
}
type Z = X & Y; // age: never（number & string? 仍然冲突）

// 2. interface 声明合并
interface Box {
  name: string;
}
interface Box {
  name: number;
} // 报错！同名基础类型冲突

interface Box {
  age?: number;
}
interface Box {
  age: number;
} // OK，最终是 age?: number（可选吃掉必选）
```

### 交叉类型 & 的同名非基础类型合并规则（超级绕，99% 人答错）

| 合并顺序                                     | 结果（从右往左覆盖）                    |
| -------------------------------------------- | --------------------------------------- |
| `type A = { x: string } & { x: number }`     | `x: never`（基础类型冲突）              |
| `type B = { x: { a: 1 } } & { x: { b: 2 } }` | `x: { a: 1; b: 2 }`（对象合并）         |
| `type C = { x(): void } & { x(): string }`   | `x(): string`（最后一个函数覆盖前面的） |
| `type D = { x?: number } & { x: string }`    | `x: string`（必选覆盖可选）             |
| `type E = { x: string } & { x?: number }`    | `x: string`（前面的必选胜出）           |

### 面试终极口诀（背下来直接秒杀）

| 场景                   | 用什么？          | 同名基础类型 | 同名非基础类型                 |
| ---------------------- | ----------------- | ------------ | ------------------------------ |
| interface 同名自动合并 | interface         | 报错         | 必须兼容（可选吃必选）         |
| 手动组合多个类型       | type + `&`        | 报错         | 从右往左覆盖（必选吃可选）     |
| 想让属性变成必选       | 用 `&` 交叉       | —            | 把 `{ x?: T }` 放前面被覆盖掉  |
| 想让属性保持可选       | 用 interface 合并 | —            | 可选属性放后面会吃掉前面的必选 |

### 2025 年大厂标准答案（直接说就能拿高分）

面试官：TypeScript 中同名属性合并，有几种方式？规则是什么？

标准回答：
TypeScript 有两种同名属性合并机制，规则完全相反：

1. interface 声明合并（自动触发）

   - 基础类型同名 → 报错
   - 非基础类型 → 必须类型兼容，可选属性会吃掉必选（最终是可选）

2. 交叉类型 `&`（手动触发）
   - 基础类型同名 → 报错（变成 never）
   - 非基础类型 → 从右往左覆盖，必选属性会吃掉可选（最终是必选）

实际项目中：

- 扩展第三方库 → 用 interface 声明合并
- 组合多个对象类型、强制属性必选 → 用 `type New = Old & { id: string }`

这两种方式千万不能混用，否则行为完全相反！

需要我出 8 道交叉类型 vs interface 合并的经典陷阱题吗？全是阿里/字节/腾讯原题！
