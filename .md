

### 1️⃣ 闭包与 IIFE（立即执行函数）有什么关系？

**答：**

* IIFE 是立即执行的函数表达式，通常用于创建私有作用域。
* 当 IIFE 内部返回函数引用外部变量时，就形成闭包。
* 作用：利用闭包保存局部变量，避免污染全局作用域。

---

### 2️⃣ 闭包可以在类（class）中使用吗？

**答：**

* ✅ 可以。
* 在类的构造函数或方法中定义内部函数，引用实例属性或局部变量，即可形成闭包。
* 可用于实现**私有成员和方法**，实现封装。

---

### 3️⃣ 闭包在异步编程（Promise/async）中有什么表现？

**答：**

* 异步函数或 Promise 回调中引用外部变量时会形成闭包。
* 允许回调函数访问函数执行时的作用域，即使异步执行晚于外层函数返回。
* 常用于保存异步操作状态、延迟变量访问或保持上下文。

---

### 4️⃣ 闭包与函数柯里化（Currying）之间的关系？

**答：**

* 柯里化本质上是**多层嵌套函数**，每层函数引用外层参数形成闭包。
* 闭包用于保存前一次函数调用的参数，实现参数累积和延迟执行。

---

### 5️⃣ 闭包能否在箭头函数中使用？

**答：**

* ✅ 可以。
* 箭头函数不会创建自己的 `this`、`arguments` 和 `super`，但仍然可以形成闭包，访问外层作用域的变量。

---

### 6️⃣ 闭包如何影响函数的 this 绑定？

**答：**

* 闭包自身不改变 `this`，仍按正常规则绑定。
* 箭头函数闭包会捕获外层函数的 `this`，避免手动绑定。
* 闭包在异步回调中可通过 `bind` 或箭头函数保持上下文。

---

### 7️⃣ 闭包与高阶函数的关系？

**答：**

* 高阶函数是**接受函数或返回函数的函数**。
* 返回的函数如果引用了外层变量，就形成闭包。
* 高阶函数 + 闭包是函数式编程常用模式（如计数器、缓存、柯里化）。

---

### 8️⃣ 闭包如何帮助实现惰性计算？

**答：**

* 闭包可以延迟计算，保存计算状态。
* 当结果第一次访问时计算，后续直接返回缓存的值（类似 memoization），避免重复计算。

---

### 9️⃣ 闭包如何模拟块级作用域（在 ES6 之前）？

**答：**

* 在 ES5 之前，`var` 是函数级作用域，没有块级作用域。
* 可通过 **IIFE + 闭包** 创建局部作用域，封装块内变量，避免外部访问。

---

### 🔟 闭包在性能调优时需要注意什么？

**答：**

* **避免过度嵌套**：作用域链过长增加查找成本。
* **及时释放闭包引用**：不再使用时置为 null，减少堆内存占用。
* **减少闭包持有的变量**：只保留必要的引用，避免 GC 压力。
* **谨慎循环闭包**：防止共享变量导致逻辑错误和内存浪费。


